{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EpiJinn Work in progress! EpiJinn is a Python package for working with modified (methylated) nucleotides. Create a readable report from bedMethyl files created by modkit . Annotate prokaryotic DNA methylase enzyme recognition sites in a Biopython SeqRecord. Check whether recognition sites of prokaryotic DNA methylase enzymes overlap with a recognition site of a restriction enzyme , in a DNA sequence. Methylation of restriction site nucleotides blocks recognition/restriction and thus DNA assembly. The software is geared towards working with plasmids. Several more future functionalities are planned: comparing methylation status with expected methylation levels; methylase site recognition etc. Install pip install git+https://github.com/Edinburgh-Genome-Foundry/EpiJinn.git See additional install instructions for the PDF Reports dependency, and its Weasyprint dependency. Usage bedMethyl files import epijinn bedmethylitemgroup = epijinn . read_sample_sheet ( sample_sheet = \"sample_sheet.csv\" , genbank_dir = 'genbank' , bedmethyl_dir = 'bedmethyl' , parameter_sheet = 'param_sheet.csv' ,) bedmethylitemgroup . perform_all_analysis_in_bedmethylitemgroup () epijinn . write_bedmethylitemgroup_report ( bedmethylitemgroup = bedmethylitemgroup , pdf_file = \"report.pdf\" , html_file = \"report.html\" ) Both pdf_file and html_file are optional, specify None to exclude either of them. An example sample sheet and parameter sheet is included in the examples directory. Recognition site overlap The module contains the Methylator class for storing a sequence, methylation enzymes and a restriction enzyme recognition site. It has a method for finding overlaps, and uses DNA Chisel to find sequence matches. An example overlap: ...ccgcatgaagggcgcgccaggtctcaccctgaattcgcg... ggtctc : BsaI restriction site CCAGGTCTCACC : Match in positive strand CCWGG : Dcm methylation site * : methylated cytosine * : methylated cytosine (on other strand) For information on the effect of DNA methylation on each enzyme, see the Restriction Enzyme Database . import epijinn methylator = epijinn . Methylator ( sequence = str ( sequence ), site = site_BsaI ) methyl . find_methylation_sites_in_pattern () Example import epijinn import Bio sequence = 'ATGTCCCCATGCCTAC' + 'AGCAAGGC' + 'CGTCTC' + 'A' + 'GGCCCCCCCCCCCCA' # seq + EcoBI (+ BsmBI +) EcoBI + seq rest_dict = Bio . Restriction . Restriction_Dictionary . rest_dict site_BsmBI = rest_dict [ 'BsmBI' ][ 'site' ] epijinn . EcoBI . sequence # 'TGANNNNNNNNTGCT' methylator = epijinn . Methylator ( sequence , site = site_BsmBI ) methylator . find_methylation_sites_in_pattern () print ( methylator . report ) Result: Matches against methylase enzyme sites: EcoKDam ======= Region: 22-32(+) Positive strand: - Negative strand: - EcoKDcm ======= Region: 21-33(+) Positive strand: - Negative strand: - EcoBI ===== Region: 13-42(+) Positive strand: - Match in negative strand: TACAGCAAATCCGTCTCAGGCCCCCCCCC EcoKI ===== Region: 14-41(+) Positive strand: - Negative strand: - DNA sulfur modification The same approach can be used for finding enzyme site overlaps with other epigenetic modifications. For example, in DNA phosphorothioation, an oxygen on the DNA backbone is replaced with sulfur. thio = epijinn . Methylator ( sequence , site = site_BsmBI , methylases = epijinn . DND ) thio . find_methylation_sites_in_pattern () This returns an overlap with a putative dnd target site of Streptomyces lividans 1326 with conserved sequence GGCC: Dnd_Sli1326 =========== Region: 21-33(+) Match in positive strand: GGCCGTCTCAGG Match in negative strand: GGCCGTCTCAGG Versioning EpiJinn uses the semantic versioning scheme. License = GPLv3+ Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh EpiJinn was written at the Edinburgh Genome Foundry by Peter Vegh , and is released under the GPLv3 license.","title":"Home"},{"location":"#epijinn","text":"Work in progress! EpiJinn is a Python package for working with modified (methylated) nucleotides. Create a readable report from bedMethyl files created by modkit . Annotate prokaryotic DNA methylase enzyme recognition sites in a Biopython SeqRecord. Check whether recognition sites of prokaryotic DNA methylase enzymes overlap with a recognition site of a restriction enzyme , in a DNA sequence. Methylation of restriction site nucleotides blocks recognition/restriction and thus DNA assembly. The software is geared towards working with plasmids. Several more future functionalities are planned: comparing methylation status with expected methylation levels; methylase site recognition etc.","title":"EpiJinn"},{"location":"#install","text":"pip install git+https://github.com/Edinburgh-Genome-Foundry/EpiJinn.git See additional install instructions for the PDF Reports dependency, and its Weasyprint dependency.","title":"Install"},{"location":"#usage","text":"","title":"Usage"},{"location":"#bedmethyl-files","text":"import epijinn bedmethylitemgroup = epijinn . read_sample_sheet ( sample_sheet = \"sample_sheet.csv\" , genbank_dir = 'genbank' , bedmethyl_dir = 'bedmethyl' , parameter_sheet = 'param_sheet.csv' ,) bedmethylitemgroup . perform_all_analysis_in_bedmethylitemgroup () epijinn . write_bedmethylitemgroup_report ( bedmethylitemgroup = bedmethylitemgroup , pdf_file = \"report.pdf\" , html_file = \"report.html\" ) Both pdf_file and html_file are optional, specify None to exclude either of them. An example sample sheet and parameter sheet is included in the examples directory.","title":"bedMethyl files"},{"location":"#recognition-site-overlap","text":"The module contains the Methylator class for storing a sequence, methylation enzymes and a restriction enzyme recognition site. It has a method for finding overlaps, and uses DNA Chisel to find sequence matches. An example overlap: ...ccgcatgaagggcgcgccaggtctcaccctgaattcgcg... ggtctc : BsaI restriction site CCAGGTCTCACC : Match in positive strand CCWGG : Dcm methylation site * : methylated cytosine * : methylated cytosine (on other strand) For information on the effect of DNA methylation on each enzyme, see the Restriction Enzyme Database . import epijinn methylator = epijinn . Methylator ( sequence = str ( sequence ), site = site_BsaI ) methyl . find_methylation_sites_in_pattern ()","title":"Recognition site overlap"},{"location":"#example","text":"import epijinn import Bio sequence = 'ATGTCCCCATGCCTAC' + 'AGCAAGGC' + 'CGTCTC' + 'A' + 'GGCCCCCCCCCCCCA' # seq + EcoBI (+ BsmBI +) EcoBI + seq rest_dict = Bio . Restriction . Restriction_Dictionary . rest_dict site_BsmBI = rest_dict [ 'BsmBI' ][ 'site' ] epijinn . EcoBI . sequence # 'TGANNNNNNNNTGCT' methylator = epijinn . Methylator ( sequence , site = site_BsmBI ) methylator . find_methylation_sites_in_pattern () print ( methylator . report ) Result: Matches against methylase enzyme sites: EcoKDam ======= Region: 22-32(+) Positive strand: - Negative strand: - EcoKDcm ======= Region: 21-33(+) Positive strand: - Negative strand: - EcoBI ===== Region: 13-42(+) Positive strand: - Match in negative strand: TACAGCAAATCCGTCTCAGGCCCCCCCCC EcoKI ===== Region: 14-41(+) Positive strand: - Negative strand: -","title":"Example"},{"location":"#dna-sulfur-modification","text":"The same approach can be used for finding enzyme site overlaps with other epigenetic modifications. For example, in DNA phosphorothioation, an oxygen on the DNA backbone is replaced with sulfur. thio = epijinn . Methylator ( sequence , site = site_BsmBI , methylases = epijinn . DND ) thio . find_methylation_sites_in_pattern () This returns an overlap with a putative dnd target site of Streptomyces lividans 1326 with conserved sequence GGCC: Dnd_Sli1326 =========== Region: 21-33(+) Match in positive strand: GGCCGTCTCAGG Match in negative strand: GGCCGTCTCAGG","title":"DNA sulfur modification"},{"location":"#versioning","text":"EpiJinn uses the semantic versioning scheme.","title":"Versioning"},{"location":"#license-gplv3","text":"Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh EpiJinn was written at the Edinburgh Genome Foundry by Peter Vegh , and is released under the GPLv3 license.","title":"License = GPLv3+"},{"location":"reference/epijinn/","text":"Module epijinn View Source from .version import __version__ from .Bedmethyl import BedmethylItem , BedmethylItemGroup , read_sample_sheet from .Methyl import Methylase , Methylator , METHYLASES , annotate_methylation from .dnd import Dnd , DND from .reports import write_bedmethylitemgroup_report Sub-modules epijinn.Bedmethyl epijinn.Methyl epijinn.dnd epijinn.reports epijinn.version Variables DND METHYLASES","title":"Index"},{"location":"reference/epijinn/#module-epijinn","text":"View Source from .version import __version__ from .Bedmethyl import BedmethylItem , BedmethylItemGroup , read_sample_sheet from .Methyl import Methylase , Methylator , METHYLASES , annotate_methylation from .dnd import Dnd , DND from .reports import write_bedmethylitemgroup_report","title":"Module epijinn"},{"location":"reference/epijinn/#sub-modules","text":"epijinn.Bedmethyl epijinn.Methyl epijinn.dnd epijinn.reports epijinn.version","title":"Sub-modules"},{"location":"reference/epijinn/#variables","text":"DND METHYLASES","title":"Variables"},{"location":"reference/epijinn/Bedmethyl/","text":"Module epijinn.Bedmethyl View Source # Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh # # This file is part of EpiJinn. # # EpiJinn is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. # # EpiJinn is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. # # You should have received a copy of the GNU General Public License along with Ediacara. If not, see <https://www.gnu.org/licenses/>. import copy import os import pandas import matplotlib.pyplot as plt import Bio import dna_features_viewer from .Methyl import METHYLASES from .Methyl import annotate_methylation COMPLEMENTS = { \"A\" : \"T\" , \"C\" : \"G\" , \"G\" : \"C\" , \"T\" : \"A\" , } # From https://github.com/nanoporetech/modkit/blob/master/book/src/intro_bedmethyl.md BEDMETHYL_HEADER = [ \"chrom\" , \"start_position\" , \"end_position\" , \"modified_base_code_and_motif\" , \"score\" , \"strand\" , \"strand_start_position\" , \"strand_end_position\" , \"color\" , \"Nvalid_cov\" , \"percent_modified\" , \"Nmod\" , \"Ncanonical\" , \"Nother_mod\" , \"Ndelete\" , \"Nfail\" , \"Ndiff\" , \"Nnocall\" , ] # Remove duplicate and unnecessary columns from report: columns_for_pdf_report = [ BEDMETHYL_HEADER [ i ] for i in [ 1 , 5 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 ] ] + [ \"status\" ] # added during binarization DATA_DIR = os . path . join ( os . path . dirname ( os . path . realpath ( __file__ )), \"data\" ) # For looking up modified_base_code_and_motif entries in bedmethyl: MODIFICATION_CODES = pandas . read_csv ( os . path . join ( DATA_DIR , \"mod_base_codes.csv\" )) # Adapted From https://github.com/samtools/hts-specs/blob/master/SAMtags.pdf class CustomTranslator ( dna_features_viewer . BiopythonTranslator ): \"\"\"Custom translator used for the main plot.\"\"\" def compute_filtered_features ( self , features ): \"\"\"Display only selected features.\"\"\" filtered_features = [] n = 8 # a good number of features to display # Keep longest features if len ( features ) > n : feature_lengths = [] for feature in features : feature_lengths += [ len ( feature . location )] feature_lengths . sort ( reverse = True ) max_length = feature_lengths [ n ] for feature in features : if len ( feature . location ) > max_length : filtered_features += [ feature ] else : # no need to do anything if not enough features filtered_features = features return filtered_features class PatternTranslator ( dna_features_viewer . BiopythonTranslator ): \"\"\"Custom translator used for the pattern annotation plot.\"\"\" def compute_feature_color ( self , feature ): status = \"status\" # Values are from binarize_bed() : if feature . qualifiers [ status ] == \"1\" : return \"red\" elif feature . qualifiers [ status ] == \"U\" : return \"yellow\" elif feature . qualifiers [ status ] == \"0\" : return \"grey\" # to be implemented later: elif feature . qualifiers [ status ] == \"?\" : return \"tab:cyan\" # There should be no other options. class BedResult : \"\"\"Results of a bedmethyl table analysis.\"\"\" def __init__ ( self , modification , bed , record ): self . feature_cutoff = 50 # do not create a plot if there are more features self . modification = modification self . mod_abbreviation = MODIFICATION_CODES . loc [ MODIFICATION_CODES [ \"Code\" ] == self . modification ] . Abbreviation . iloc [ 0 ] # there is only one entry so we take the first self . mod_name = MODIFICATION_CODES . loc [ MODIFICATION_CODES [ \"Code\" ] == self . modification ] . Name . iloc [ 0 ] self . mod_chebi = MODIFICATION_CODES . loc [ MODIFICATION_CODES [ \"Code\" ] == self . modification ] . ChEBI . iloc [ 0 ] self . unmodified_base = MODIFICATION_CODES . loc [ MODIFICATION_CODES [ \"Code\" ] == self . modification ] . Unmodified_base . iloc [ 0 ] self . bed = bed self . record = record # FILTER (ANNOTATED) RECORD AND ADD STATUS: filtered_features = [] labelstart = ( \"@epijinn(\" + self . unmodified_base + \", strand=\" ) # unfinished to account for +/- strands for feature in record . features : if feature . id == \"@epijinn\" : # as annotated by the function if feature . qualifiers [ \"label\" ] . startswith ( labelstart ): # To display seq in report: feature . qualifiers [ \"label\" ] = self . unmodified_base # Assign status: # no need to check for strand as the complement won't be modified location_start = int ( feature . location . start ) # expect exactly one bed table entry per modified nucleotide: status_symbol = self . bed . loc [ self . bed [ \"LOC\" ] == location_start ] . STATUS . iloc [ 0 ] # used by a custom BiopythonTranslator to colour the annotation: feature . qualifiers [ \"status\" ] = status_symbol filtered_features += [ feature ] record . features = filtered_features if len ( self . record . features ) > self . feature_cutoff : self . img_created = False else : self . img_created = True fig , ax1 = plt . subplots ( 1 , 1 , figsize = ( 8 , 3 )) graphic_record = PatternTranslator () . translate_record ( self . record ) graphic_record . plot ( ax = ax1 , with_ruler = False , strand_in_label_threshold = 4 ) self . plot = fig class BedmethylItem : \"\"\"Analyse a bedmethyl file. **Parameters** **sample** > The name of the sample, for example a barcode id (`str`). **reference** > A Biopython SeqRecord. **bedmethyl** > A pandas dataframe of a bedmethyl file for the reference. \"\"\" def __init__ ( self , sample , reference , bedmethyl ): self . sample = sample self . record = reference self . name = reference . name self . id = reference . id self . bed = bedmethyl self . reference_length = len ( self . record ) def perform_analysis ( self , parameter_dict ): \"\"\"Perform analysis and plot the sequence.\"\"\" methylase_str = parameter_dict [ \"methylases\" ] methylase = METHYLASES [ methylase_str ] self . fig = self . plot_record () self . results = [] # BedResult instances. For easy reference in pug template. for modification in self . bed . modified_base_code_and_motif . unique (): # RUN BED SUBSET ETC bed_subtype = self . subset_bed_to_mod_subtype ( self . bed , mod = modification ) annotated_record , bed_pattern_match = self . subset_bed_to_pattern_match ( methylase , bed = bed_subtype ) bed_binarized = self . binarize_bed ( bed_pattern_match , met_cutoff = parameter_dict [ \"methylated_cutoff\" ], nonmet_cutoff = parameter_dict [ \"unmethylated_cutoff\" ], ) final_bed = subset_bed_columns ( bed_binarized ) bedresult = BedResult ( modification , bed = final_bed , record = annotated_record ) self . results += [ bedresult ] def annotate_record ( self ): return self . record def plot_record ( self ): fig , ax1 = plt . subplots ( 1 , 1 , figsize = ( 8 , 2 )) graphic_record = CustomTranslator () . translate_record ( self . record ) graphic_record . plot ( ax = ax1 , with_ruler = False , strand_in_label_threshold = 4 ) return fig @staticmethod def subset_bed_to_mod_subtype ( bed , mod ): # Columnname from Bedmethyl file specification bed_subtype = bed . loc [ bed [ \"modified_base_code_and_motif\" ] == mod ] return bed_subtype def subset_bed_to_base_matches ( self , bed = None , modified_base = \"C\" ): if bed is None : # optional bed allows linking multiple bed subset methods bed = self . bed mod_base = modified_base . upper () mod_base_complement = COMPLEMENTS [ mod_base ] # POSITIVE STRAND matching_positions_on_positive_strand = [ pos for pos , base in enumerate ( str ( self . record . seq . upper ())) if base == mod_base ] # Columnname from Bedmethyl file specification: positive_strand_filter = bed [ \"start_position\" ] . isin ( matching_positions_on_positive_strand ) & ( bed [ \"strand\" ] == \"+\" ) # NEGATIVE STRAND matching_positions_on_negative_strand = [ pos for pos , base in enumerate ( str ( self . record . seq . upper ())) if base == mod_base_complement ] negative_strand_filter = bed [ \"start_position\" ] . isin ( matching_positions_on_negative_strand ) & ( bed [ \"strand\" ] == \"-\" ) bed_basematch = bed . loc [ positive_strand_filter | negative_strand_filter ] return bed_basematch def subset_bed_to_pattern_match ( self , methylase , bed = None ): if bed is None : # optional bed allows linking multiple bed subset methods bed = self . bed methylated_index = methylase . index_pos mod_base = methylase . sequence [ methylated_index ] . upper () record_copy = copy . deepcopy ( self . record ) annotated_record = annotate_methylation ( record_copy , methylases = [ methylase ]) # CREATE LIST OF POSITIONS positive_strand_locations = [] negative_strand_locations = [] label_pos = \"@epijinn(\" + mod_base + \", strand=1)\" label_neg = \"@epijinn(\" + mod_base + \", strand=-1)\" for feature in annotated_record . features : if feature . id == \"@epijinn\" : # as annotated by function above if feature . qualifiers [ \"label\" ] == label_pos : positive_strand_locations += [ feature . location . start ] elif feature . qualifiers [ \"label\" ] == label_neg : negative_strand_locations += [ feature . location . start ] # SUBSET USING POSITIONS # Columnname from Bedmethyl file specification: positive_strand_filter = bed [ \"start_position\" ] . isin ( positive_strand_locations ) & ( bed [ \"strand\" ] == \"+\" ) negative_strand_filter = bed [ \"start_position\" ] . isin ( negative_strand_locations ) & ( bed [ \"strand\" ] == \"-\" ) bed_pattern_match = bed . loc [ positive_strand_filter | negative_strand_filter ] return annotated_record , bed_pattern_match @staticmethod def binarize_bed ( bed , met_cutoff , nonmet_cutoff ): bed [ \"status\" ] = \"U\" # prefill undetermined for index , row in bed . iterrows (): if row [ \"percent_modified\" ] >= float ( met_cutoff ) * 100 : bed . loc [ index , \"status\" ] = \"1\" # methylated, symbol may change elif row [ \"percent_modified\" ] <= float ( nonmet_cutoff ) * 100 : bed . loc [ index , \"status\" ] = \"0\" # unmethylated # symbol \"?\" reserved for low coverage to be implemented later return bed def read_sample_sheet ( sample_sheet , genbank_dir = \"\" , bedmethyl_dir = \"\" , parameter_sheet = \"\" ): \"\"\"Read a sample sheet into a BedmethylItemGroup. **Parameters** **sample_sheet** > CSV file path (`str`). No header and columns must be in this order: projectname, sample, Genbank name (without extension), bedmethyl file. **genbank_dir** > Directory of the Genbank files (`str`). Default: local directory. **bedmethyl_dir** > Directory of the bedmethyl files (`str`). Default: local directory. **parameter_sheet** > CSV file path (`str`). Use 'Parameter', 'Value' header for columns. If a 'projectname' is specified, it overwrites the sample sheet value. \"\"\" # READ PARAMETERS param_df = pandas . read_csv ( parameter_sheet , usecols = [ \"Parameter\" , \"Value\" ]) parameter_dict = dict ( param_df . values ) # READ SAMPLES sample_df = pandas . read_csv ( sample_sheet , header = None ) # add columnnames # CREATE ITEMS # We allow Sequeduct to specify the projectname as a command parameter as well; if not \"projectname\" in parameter_dict : # first entry of the first column (contains projectname): parameter_dict [ \"projectname\" ] = sample_df . iloc [ 0 , 0 ] # Allow the user to not specify these in the sheet: # The default cutoffs are based on preliminary data. if not \"methylated_cutoff\" in parameter_dict : parameter_dict [ \"methylated_cutoff\" ] = 0.7 if not \"unmethylated_cutoff\" in parameter_dict : parameter_dict [ \"unmethylated_cutoff\" ] = 0.3 bedmethylitems = [] for index , row in sample_df . iterrows (): genbank_name = row [ 2 ] # number specified by the sample sheet format genbank_path = os . path . join ( genbank_dir , genbank_name + \".gb\" ) # Genbank ext record = Bio . SeqIO . read ( genbank_path , \"genbank\" ) record . id = genbank_name record . name = genbank_name record . annotations [ \"molecule_type\" ] = \"DNA\" bed_name = row [ 3 ] # number specified by the sample sheet format bed_path = os . path . join ( bedmethyl_dir , bed_name ) bed_df = pandas . read_csv ( bed_path , header = None , delimiter = \" \\t \" ) bed_df . columns = BEDMETHYL_HEADER bedmethylitems += [ BedmethylItem ( sample = row [ 1 ], reference = record , bedmethyl = bed_df ) ] # number specified by the sample sheet format bedmethylitemgroup = BedmethylItemGroup ( bedmethylitems = bedmethylitems , parameter_dict = parameter_dict ) return bedmethylitemgroup def subset_bed_columns ( bed ): bed_report = bed [ columns_for_pdf_report ] # These were designed to be more informative and fit the report: new_columnnames = [ \"LOC\" , \"Strand\" , \"COV\" , \"% mod\" , \"MOD\" , \"STD\" , \"OTH\" , \"del\" , \"fail\" , \"diff\" , \"nocall\" , \"STATUS\" , ] bed_report . columns = new_columnnames return bed_report class BedmethylItemGroup : \"\"\"A group of BedmethylItem instances for reporting. **Parameters** **bedmethylitems** > A list of BedmethylItem instances. **parameter_dict** > A dictionary of analysis parameters (`dict`). \"\"\" def __init__ ( self , bedmethylitems , parameter_dict ): self . bedmethylitems = bedmethylitems self . parameter_dict = parameter_dict self . number_of_samples = len ( bedmethylitems ) def perform_all_analysis_in_bedmethylitemgroup ( self ): for bedmethylitem in self . bedmethylitems : bedmethylitem . perform_analysis ( parameter_dict = self . parameter_dict ) self . comparisons_performed = True Variables BEDMETHYL_HEADER COMPLEMENTS DATA_DIR METHYLASES MODIFICATION_CODES columns_for_pdf_report Functions read_sample_sheet def read_sample_sheet ( sample_sheet , genbank_dir = '' , bedmethyl_dir = '' , parameter_sheet = '' ) Read a sample sheet into a BedmethylItemGroup. Parameters sample_sheet CSV file path ( str ). No header and columns must be in this order: projectname, sample, Genbank name (without extension), bedmethyl file. genbank_dir Directory of the Genbank files ( str ). Default: local directory. bedmethyl_dir Directory of the bedmethyl files ( str ). Default: local directory. parameter_sheet CSV file path ( str ). Use 'Parameter', 'Value' header for columns. If a 'projectname' is specified, it overwrites the sample sheet value. View Source def read_sample_sheet ( sample_sheet , genbank_dir = \"\" , bedmethyl_dir = \"\" , parameter_sheet = \"\" ) : \" \"\" Read a sample sheet into a BedmethylItemGroup. **Parameters** **sample_sheet** > CSV file path (`str`). No header and columns must be in this order: projectname, sample, Genbank name (without extension), bedmethyl file. **genbank_dir** > Directory of the Genbank files (`str`). Default: local directory. **bedmethyl_dir** > Directory of the bedmethyl files (`str`). Default: local directory. **parameter_sheet** > CSV file path (`str`). Use 'Parameter', 'Value' header for columns. If a 'projectname' is specified, it overwrites the sample sheet value. \"\" \" # READ PARAMETERS param_df = pandas . read_csv ( parameter_sheet , usecols = [ \"Parameter\" , \"Value\" ] ) parameter_dict = dict ( param_df . values ) # READ SAMPLES sample_df = pandas . read_csv ( sample_sheet , header = None ) # add columnnames # CREATE ITEMS # We allow Sequeduct to specify the projectname as a command parameter as well; if not \"projectname\" in parameter_dict : # first entry of the first column (contains projectname): parameter_dict [ \"projectname\" ] = sample_df . iloc [ 0 , 0 ] # Allow the user to not specify these in the sheet: # The default cutoffs are based on preliminary data. if not \"methylated_cutoff\" in parameter_dict : parameter_dict [ \"methylated_cutoff\" ] = 0.7 if not \"unmethylated_cutoff\" in parameter_dict : parameter_dict [ \"unmethylated_cutoff\" ] = 0.3 bedmethylitems = [] for index , row in sample_df . iterrows () : genbank_name = row [ 2 ] # number specified by the sample sheet format genbank_path = os . path . join ( genbank_dir , genbank_name + \".gb\" ) # Genbank ext record = Bio . SeqIO . read ( genbank_path , \"genbank\" ) record . id = genbank_name record . name = genbank_name record . annotations [ \"molecule_type\" ] = \"DNA\" bed_name = row [ 3 ] # number specified by the sample sheet format bed_path = os . path . join ( bedmethyl_dir , bed_name ) bed_df = pandas . read_csv ( bed_path , header = None , delimiter = \" \\t \" ) bed_df . columns = BEDMETHYL_HEADER bedmethylitems += [ BedmethylItem ( sample = row [ 1 ] , reference = record , bedmethyl = bed_df ) ] # number specified by the sample sheet format bedmethylitemgroup = BedmethylItemGroup ( bedmethylitems = bedmethylitems , parameter_dict = parameter_dict ) return bedmethylitemgroup subset_bed_columns def subset_bed_columns ( bed ) View Source def subset_bed_columns ( bed ) : bed_report = bed [ columns_for_pdf_report ] # These were designed to be more informative and fit the report : new_columnnames = [ \"LOC\", \"Strand\", \"COV\", \"% mod\", \"MOD\", \"STD\", \"OTH\", \"del\", \"fail\", \"diff\", \"nocall\", \"STATUS\", ] bed_report . columns = new_columnnames return bed_report Classes BedResult class BedResult ( modification , bed , record ) Results of a bedmethyl table analysis. View Source class BedResult : \"\"\"Results of a bedmethyl table analysis.\"\"\" def __init__ ( self , modification , bed , record ) : self . feature_cutoff = 50 # do not create a plot if there are more features self . modification = modification self . mod_abbreviation = MODIFICATION_CODES . loc [ MODIFICATION_CODES[\"Code\" ] == self . modification ] . Abbreviation . iloc [ 0 ] # there is only one entry so we take the first self . mod_name = MODIFICATION_CODES . loc [ MODIFICATION_CODES[\"Code\" ] == self . modification ] . Name . iloc [ 0 ] self . mod_chebi = MODIFICATION_CODES . loc [ MODIFICATION_CODES[\"Code\" ] == self . modification ] . ChEBI . iloc [ 0 ] self . unmodified_base = MODIFICATION_CODES . loc [ MODIFICATION_CODES[\"Code\" ] == self . modification ] . Unmodified_base . iloc [ 0 ] self . bed = bed self . record = record # FILTER ( ANNOTATED ) RECORD AND ADD STATUS : filtered_features = [] labelstart = ( \"@epijinn(\" + self . unmodified_base + \", strand=\" ) # unfinished to account for +/- strands for feature in record . features : if feature . id == \"@epijinn\" : # as annotated by the function if feature . qualifiers [ \"label\" ] . startswith ( labelstart ) : # To display seq in report : feature . qualifiers [ \"label\" ] = self . unmodified_base # Assign status : # no need to check for strand as the complement won ' t be modified location_start = int ( feature . location . start ) # expect exactly one bed table entry per modified nucleotide : status_symbol = self . bed . loc [ self.bed[\"LOC\" ] == location_start ] . STATUS . iloc [ 0 ] # used by a custom BiopythonTranslator to colour the annotation : feature . qualifiers [ \"status\" ] = status_symbol filtered_features += [ feature ] record . features = filtered_features if len ( self . record . features ) > self . feature_cutoff : self . img_created = False else : self . img_created = True fig , ax1 = plt . subplots ( 1 , 1 , figsize = ( 8 , 3 )) graphic_record = PatternTranslator (). translate_record ( self . record ) graphic_record . plot ( ax = ax1 , with_ruler = False , strand_in_label_threshold = 4 ) self . plot = fig BedmethylItem class BedmethylItem ( sample , reference , bedmethyl ) Analyse a bedmethyl file. Parameters sample The name of the sample, for example a barcode id ( str ). reference A Biopython SeqRecord. bedmethyl A pandas dataframe of a bedmethyl file for the reference. View Source class BedmethylItem : \"\"\"Analyse a bedmethyl file. **Parameters** **sample** > The name of the sample, for example a barcode id (`str`). **reference** > A Biopython SeqRecord. **bedmethyl** > A pandas dataframe of a bedmethyl file for the reference. \"\"\" def __init__ ( self , sample , reference , bedmethyl ) : self . sample = sample self . record = reference self . name = reference . name self . id = reference . id self . bed = bedmethyl self . reference_length = len ( self . record ) def perform_analysis ( self , parameter_dict ) : \"\"\"Perform analysis and plot the sequence.\"\"\" methylase_str = parameter_dict [ \"methylases\" ] methylase = METHYLASES [ methylase_str ] self . fig = self . plot_record () self . results = [] # BedResult instances . For easy reference in pug template . for modification in self . bed . modified_base_code_and_motif . unique () : # RUN BED SUBSET ETC bed_subtype = self . subset_bed_to_mod_subtype ( self . bed , mod = modification ) annotated_record , bed_pattern_match = self . subset_bed_to_pattern_match ( methylase , bed = bed_subtype ) bed_binarized = self . binarize_bed ( bed_pattern_match , met_cutoff = parameter_dict [ \"methylated_cutoff\" ] , nonmet_cutoff = parameter_dict [ \"unmethylated_cutoff\" ] , ) final_bed = subset_bed_columns ( bed_binarized ) bedresult = BedResult ( modification , bed = final_bed , record = annotated_record ) self . results += [ bedresult ] def annotate_record ( self ) : return self . record def plot_record ( self ) : fig , ax1 = plt . subplots ( 1 , 1 , figsize = ( 8 , 2 )) graphic_record = CustomTranslator (). translate_record ( self . record ) graphic_record . plot ( ax = ax1 , with_ruler = False , strand_in_label_threshold = 4 ) return fig @staticmethod def subset_bed_to_mod_subtype ( bed , mod ) : # Columnname from Bedmethyl file specification bed_subtype = bed . loc [ bed[\"modified_base_code_and_motif\" ] == mod ] return bed_subtype def subset_bed_to_base_matches ( self , bed = None , modified_base = \"C\" ) : if bed is None : # optional bed allows linking multiple bed subset methods bed = self . bed mod_base = modified_base . upper () mod_base_complement = COMPLEMENTS [ mod_base ] # POSITIVE STRAND matching_positions_on_positive_strand = [ pos for pos, base in enumerate(str(self.record.seq.upper())) if base == mod_base ] # Columnname from Bedmethyl file specification : positive_strand_filter = bed [ \"start_position\" ] . isin ( matching_positions_on_positive_strand ) & ( bed [ \"strand\" ] == \"+\" ) # NEGATIVE STRAND matching_positions_on_negative_strand = [ pos for pos, base in enumerate(str(self.record.seq.upper())) if base == mod_base_complement ] negative_strand_filter = bed [ \"start_position\" ] . isin ( matching_positions_on_negative_strand ) & ( bed [ \"strand\" ] == \"-\" ) bed_basematch = bed . loc [ positive_strand_filter | negative_strand_filter ] return bed_basematch def subset_bed_to_pattern_match ( self , methylase , bed = None ) : if bed is None : # optional bed allows linking multiple bed subset methods bed = self . bed methylated_index = methylase . index_pos mod_base = methylase . sequence [ methylated_index ] . upper () record_copy = copy . deepcopy ( self . record ) annotated_record = annotate_methylation ( record_copy , methylases =[ methylase ] ) # CREATE LIST OF POSITIONS positive_strand_locations = [] negative_strand_locations = [] label_pos = \"@epijinn(\" + mod_base + \", strand=1)\" label_neg = \"@epijinn(\" + mod_base + \", strand=-1)\" for feature in annotated_record . features : if feature . id == \"@epijinn\" : # as annotated by function above if feature . qualifiers [ \"label\" ] == label_pos : positive_strand_locations += [ feature.location.start ] elif feature . qualifiers [ \"label\" ] == label_neg : negative_strand_locations += [ feature.location.start ] # SUBSET USING POSITIONS # Columnname from Bedmethyl file specification : positive_strand_filter = bed [ \"start_position\" ] . isin ( positive_strand_locations ) & ( bed [ \"strand\" ] == \"+\" ) negative_strand_filter = bed [ \"start_position\" ] . isin ( negative_strand_locations ) & ( bed [ \"strand\" ] == \"-\" ) bed_pattern_match = bed . loc [ positive_strand_filter | negative_strand_filter ] return annotated_record , bed_pattern_match @staticmethod def binarize_bed ( bed , met_cutoff , nonmet_cutoff ) : bed [ \"status\" ] = \"U\" # prefill undetermined for index , row in bed . iterrows () : if row [ \"percent_modified\" ] >= float ( met_cutoff ) * 100 : bed . loc [ index, \"status\" ] = \"1\" # methylated , symbol may change elif row [ \"percent_modified\" ] <= float ( nonmet_cutoff ) * 100 : bed . loc [ index, \"status\" ] = \"0\" # unmethylated # symbol \"?\" reserved for low coverage to be implemented later return bed Static methods binarize_bed def binarize_bed ( bed , met_cutoff , nonmet_cutoff ) View Source @ staticmethod def binarize_bed ( bed , met_cutoff , nonmet_cutoff ): bed [ \"status\" ] = \"U\" # prefill undetermined for index , row in bed . iterrows (): if row [ \"percent_modified\" ] >= float ( met_cutoff ) * 100 : bed . loc [ index , \"status\" ] = \"1\" # methylated , symbol may change elif row [ \"percent_modified\" ] <= float ( nonmet_cutoff ) * 100 : bed . loc [ index , \"status\" ] = \"0\" # unmethylated # symbol \"?\" reserved for low coverage to be implemented later return bed subset_bed_to_mod_subtype def subset_bed_to_mod_subtype ( bed , mod ) View Source @ staticmethod def subset_bed_to_mod_subtype ( bed , mod ): # Columnname from Bedmethyl file specification bed_subtype = bed . loc [ bed [ \"modified_base_code_and_motif\" ] == mod ] return bed_subtype Methods annotate_record def annotate_record ( self ) View Source def annotate_record(self): return self.record perform_analysis def perform_analysis ( self , parameter_dict ) Perform analysis and plot the sequence. View Source def perform_analysis ( self , parameter_dict ) : \"\"\"Perform analysis and plot the sequence.\"\"\" methylase_str = parameter_dict [ \"methylases\" ] methylase = METHYLASES [ methylase_str ] self . fig = self . plot_record () self . results = [] # BedResult instances . For easy reference in pug template . for modification in self . bed . modified_base_code_and_motif . unique () : # RUN BED SUBSET ETC bed_subtype = self . subset_bed_to_mod_subtype ( self . bed , mod = modification ) annotated_record , bed_pattern_match = self . subset_bed_to_pattern_match ( methylase , bed = bed_subtype ) bed_binarized = self . binarize_bed ( bed_pattern_match , met_cutoff = parameter_dict [ \"methylated_cutoff\" ] , nonmet_cutoff = parameter_dict [ \"unmethylated_cutoff\" ] , ) final_bed = subset_bed_columns ( bed_binarized ) bedresult = BedResult ( modification , bed = final_bed , record = annotated_record ) self . results += [ bedresult ] plot_record def plot_record ( self ) View Source def plot_record(self): fig, ax1 = plt.subplots(1, 1, figsize=(8, 2)) graphic_record = CustomTranslator().translate_record(self.record) graphic_record.plot(ax=ax1, with_ruler=False, strand_in_label_threshold=4) return fig subset_bed_to_base_matches def subset_bed_to_base_matches ( self , bed = None , modified_base = 'C' ) View Source def subset_bed_to_base_matches ( self , bed = None , modified_base = \"C\" ) : if bed is None : # optional bed allows linking multiple bed subset methods bed = self . bed mod_base = modified_base . upper () mod_base_complement = COMPLEMENTS [ mod_base ] # POSITIVE STRAND matching_positions_on_positive_strand = [ pos for pos, base in enumerate(str(self.record.seq.upper())) if base == mod_base ] # Columnname from Bedmethyl file specification : positive_strand_filter = bed [ \"start_position\" ] . isin ( matching_positions_on_positive_strand ) & ( bed [ \"strand\" ] == \"+\" ) # NEGATIVE STRAND matching_positions_on_negative_strand = [ pos for pos, base in enumerate(str(self.record.seq.upper())) if base == mod_base_complement ] negative_strand_filter = bed [ \"start_position\" ] . isin ( matching_positions_on_negative_strand ) & ( bed [ \"strand\" ] == \"-\" ) bed_basematch = bed . loc [ positive_strand_filter | negative_strand_filter ] return bed_basematch subset_bed_to_pattern_match def subset_bed_to_pattern_match ( self , methylase , bed = None ) View Source def subset_bed_to_pattern_match ( self , methylase , bed = None ) : if bed is None : # optional bed allows linking multiple bed subset methods bed = self . bed methylated_index = methylase . index_pos mod_base = methylase . sequence [ methylated_index ] . upper () record_copy = copy . deepcopy ( self . record ) annotated_record = annotate_methylation ( record_copy , methylases =[ methylase ] ) # CREATE LIST OF POSITIONS positive_strand_locations = [] negative_strand_locations = [] label_pos = \"@epijinn(\" + mod_base + \", strand=1)\" label_neg = \"@epijinn(\" + mod_base + \", strand=-1)\" for feature in annotated_record . features : if feature . id == \"@epijinn\" : # as annotated by function above if feature . qualifiers [ \"label\" ] == label_pos : positive_strand_locations += [ feature.location.start ] elif feature . qualifiers [ \"label\" ] == label_neg : negative_strand_locations += [ feature.location.start ] # SUBSET USING POSITIONS # Columnname from Bedmethyl file specification : positive_strand_filter = bed [ \"start_position\" ] . isin ( positive_strand_locations ) & ( bed [ \"strand\" ] == \"+\" ) negative_strand_filter = bed [ \"start_position\" ] . isin ( negative_strand_locations ) & ( bed [ \"strand\" ] == \"-\" ) bed_pattern_match = bed . loc [ positive_strand_filter | negative_strand_filter ] return annotated_record , bed_pattern_match BedmethylItemGroup class BedmethylItemGroup ( bedmethylitems , parameter_dict ) A group of BedmethylItem instances for reporting. Parameters bedmethylitems A list of BedmethylItem instances. parameter_dict A dictionary of analysis parameters ( dict ). View Source class BedmethylItemGroup : \" \"\" A group of BedmethylItem instances for reporting. **Parameters** **bedmethylitems** > A list of BedmethylItem instances. **parameter_dict** > A dictionary of analysis parameters (`dict`). \"\" \" def __init__ ( self , bedmethylitems , parameter_dict ) : self . bedmethylitems = bedmethylitems self . parameter_dict = parameter_dict self . number_of_samples = len ( bedmethylitems ) def perform_all_analysis_in_bedmethylitemgroup ( self ) : for bedmethylitem in self . bedmethylitems : bedmethylitem . perform_analysis ( parameter_dict = self . parameter_dict ) self . comparisons_performed = True Methods perform_all_analysis_in_bedmethylitemgroup def perform_all_analysis_in_bedmethylitemgroup ( self ) View Source def perform_all_analysis_in_bedmethylitemgroup(self): for bedmethylitem in self.bedmethylitems: bedmethylitem.perform_analysis(parameter_dict=self.parameter_dict) self.comparisons_performed = True CustomTranslator class CustomTranslator ( features_filters = (), features_properties = None ) Custom translator used for the main plot. View Source class CustomTranslator ( dna_features_viewer . BiopythonTranslator ) : \"\"\"Custom translator used for the main plot.\"\"\" def compute_filtered_features ( self , features ) : \"\"\"Display only selected features.\"\"\" filtered_features = [] n = 8 # a good number of features to display # Keep longest features if len ( features ) > n : feature_lengths = [] for feature in features : feature_lengths += [ len(feature.location) ] feature_lengths . sort ( reverse = True ) max_length = feature_lengths [ n ] for feature in features : if len ( feature . location ) > max_length : filtered_features += [ feature ] else : # no need to do anything if not enough features filtered_features = features return filtered_features Ancestors (in MRO) dna_features_viewer.BiopythonTranslator.BiopythonTranslator.BiopythonTranslator dna_features_viewer.BiopythonTranslator.BiopythonTranslatorBase.BiopythonTranslatorBase Class variables default_feature_color graphic_record_parameters ignored_features_types label_fields Static methods quick_class_plot def quick_class_plot ( record , figure_width = 12 , ** kwargs ) Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. from dna_features_viewer import BiopythonTranslator BiopythonTranslator.quick_plot(my_record) View Source @classmethod def quick_class_plot ( cls , record , figure_width = 12 , ** kwargs ): \"\"\"Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. >>> from dna_features_viewer import BiopythonTranslator >>> BiopythonTranslator.quick_plot(my_record) \"\"\" graphic_record = cls () . translate_record ( record ) ax , _ = graphic_record . plot ( figure_width = figure_width , ** kwargs ) return ax Methods compute_feature_box_color def compute_feature_box_color ( self , feature ) Compute a box_color for this feature. View Source def compute_feature_box_color(self, feature): \"\"\"Compute a box_color for this feature.\"\"\" return \"auto\" compute_feature_box_linewidth def compute_feature_box_linewidth ( self , feature ) Compute a box_linewidth for this feature. View Source def compute_feature_box_linewidth(self, feature): \"\"\"Compute a box_linewidth for this feature.\"\"\" return 0.3 compute_feature_color def compute_feature_color ( self , feature ) Compute a color for this feature. If the feature has a color qualifier it will be used. Otherwise, the classe's default_feature_color is used. To change the behaviour, create a subclass of BiopythonTranslator and overwrite this method. View Source def compute_feature_color ( self , feature ) : \" \"\" Compute a color for this feature. If the feature has a ``color`` qualifier it will be used. Otherwise, the classe's ``default_feature_color`` is used. To change the behaviour, create a subclass of ``BiopythonTranslator`` and overwrite this method. \"\" \" if \"color\" in feature . qualifiers : color = feature . qualifiers [ \"color\" ] if isinstance ( color [ 0 ] , str ) : return \"\" . join ( feature . qualifiers [ \"color\" ] ) else : return color else : return self . default_feature_color compute_feature_fontdict def compute_feature_fontdict ( self , feature ) Compute a font dict for this feature. View Source def compute_feature_fontdict(self, feature): \"\"\"Compute a font dict for this feature.\"\"\" return None compute_feature_html def compute_feature_html ( self , feature ) Gets the 'label' of the feature. View Source def compute_feature_html(self, feature): \"\"\"Gets the 'label' of the feature.\"\"\" return self.compute_feature_label(feature) compute_feature_label def compute_feature_label ( self , feature ) Compute the label of the feature. View Source def compute_feature_label ( self , feature ) : \"\"\"Compute the label of the feature.\"\"\" label = feature . type for key in self . label_fields : if key in feature . qualifiers and len ( feature . qualifiers [ key ] ) : label = feature . qualifiers [ key ] break if isinstance ( label , list ) : label = \"|\" . join ( label ) return label compute_feature_label_link_color def compute_feature_label_link_color ( self , feature ) Compute the color of the line linking the label to its feature. View Source def compute_feature_label_link_color(self, feature): \"\"\"Compute the color of the line linking the label to its feature.\"\"\" return \"black\" compute_feature_legend_text def compute_feature_legend_text ( self , feature ) View Source def compute_feature_legend_text(self, feature): return None compute_feature_linewidth def compute_feature_linewidth ( self , feature ) Compute the edge width of the feature's arrow/rectangle. View Source def compute_feature_linewidth(self, feature): \"\"\"Compute the edge width of the feature's arrow/rectangle.\"\"\" return 1.0 compute_filtered_features def compute_filtered_features ( self , features ) Display only selected features. View Source def compute_filtered_features ( self , features ) : \"\"\"Display only selected features.\"\"\" filtered_features = [] n = 8 # a good number of features to display # Keep longest features if len ( features ) > n : feature_lengths = [] for feature in features : feature_lengths += [ len(feature.location) ] feature_lengths . sort ( reverse = True ) max_length = feature_lengths [ n ] for feature in features : if len ( feature . location ) > max_length : filtered_features += [ feature ] else : # no need to do anything if not enough features filtered_features = features return filtered_features quick_plot def quick_plot ( self , record , figure_width = 12 , ** kwargs ) Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. from dna_features_viewer import BiopythonTranslator BiopythonTranslator.quick_plot(my_record) View Source def quick_plot ( self , record , figure_width = 12 , ** kwargs ): \"\"\"Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. >>> from dna_features_viewer import BiopythonTranslator >>> BiopythonTranslator.quick_plot(my_record) \"\"\" graphic_record = self . translate_record ( record ) ax , _ = graphic_record . plot ( figure_width = figure_width , ** kwargs ) return ax translate_feature def translate_feature ( self , feature ) Translate a Biopython feature into a Dna Features Viewer feature. View Source def translate_feature(self, feature): \"\"\"Translate a Biopython feature into a Dna Features Viewer feature.\"\"\" properties = dict( label=self.compute_feature_label(feature), color=self.compute_feature_color(feature), html=self.compute_feature_html(feature), fontdict=self.compute_feature_fontdict(feature), box_linewidth=self.compute_feature_box_linewidth(feature), box_color=self.compute_feature_box_color(feature), linewidth=self.compute_feature_linewidth(feature), label_link_color=self.compute_feature_label_link_color(feature), legend_text=self.compute_feature_legend_text(feature), ) if self.features_properties is not None: other_properties = self.features_properties if hasattr(other_properties, \"__call__\"): other_properties = other_properties(feature) properties.update(other_properties) return GraphicFeature( start=feature.location.start, end=feature.location.end, strand=feature.location.strand, **properties ) translate_record def translate_record ( self , record , record_class = None , filetype = None ) Create a new GraphicRecord from a BioPython Record object. Parameters: Name Type Description Default record None A BioPython Record object or the path to a Genbank or a GFF file. None record_class None The graphic record class to use, e.g. GraphicRecord (default) or CircularGraphicRecord. Strings 'circular' and 'linear' can also be provided. None filetype None Used only when a Genbank or a GFF file is provided; one of \"genbank\" or \"gff\" to be used. Default None infers from file extension. None View Source def translate_record ( self , record , record_class = None , filetype = None ) : \"\"\"Create a new GraphicRecord from a BioPython Record object. Parameters ---------- record A BioPython Record object or the path to a Genbank or a GFF file. record_class The graphic record class to use, e.g. GraphicRecord (default) or CircularGraphicRecord. Strings 'circular' and 'linear' can also be provided. filetype Used only when a Genbank or a GFF file is provided; one of \" genbank \" or \" gff \" to be used. Default None infers from file extension. \"\"\" classes = { \"linear\" : GraphicRecord , \"circular\" : CircularGraphicRecord , None : GraphicRecord , } if record_class in classes : record_class = classes [ record_class ] if isinstance ( record , str ) or hasattr ( record , \"read\" ) : record = load_record ( record , filetype = filetype ) filtered_features = self . compute_filtered_features ( record . features ) return record_class ( sequence_length = len ( record ), sequence = str ( record . seq ) if record . seq . defined else None , features =[ self.translate_feature(feature) for feature in filtered_features if feature.location is not None ] , ** self . graphic_record_parameters ) PatternTranslator class PatternTranslator ( features_filters = (), features_properties = None ) Custom translator used for the pattern annotation plot. View Source class PatternTranslator ( dna_features_viewer . BiopythonTranslator ) : \"\"\"Custom translator used for the pattern annotation plot.\"\"\" def compute_feature_color ( self , feature ) : status = \"status\" # Values are from binarize_bed () : if feature . qualifiers [ status ] == \"1\" : return \"red\" elif feature . qualifiers [ status ] == \"U\" : return \"yellow\" elif feature . qualifiers [ status ] == \"0\" : return \"grey\" # to be implemented later : elif feature . qualifiers [ status ] == \"?\" : return \"tab:cyan\" # There should be no other options . Ancestors (in MRO) dna_features_viewer.BiopythonTranslator.BiopythonTranslator.BiopythonTranslator dna_features_viewer.BiopythonTranslator.BiopythonTranslatorBase.BiopythonTranslatorBase Class variables default_feature_color graphic_record_parameters ignored_features_types label_fields Static methods quick_class_plot def quick_class_plot ( record , figure_width = 12 , ** kwargs ) Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. from dna_features_viewer import BiopythonTranslator BiopythonTranslator.quick_plot(my_record) View Source @classmethod def quick_class_plot ( cls , record , figure_width = 12 , ** kwargs ): \"\"\"Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. >>> from dna_features_viewer import BiopythonTranslator >>> BiopythonTranslator.quick_plot(my_record) \"\"\" graphic_record = cls () . translate_record ( record ) ax , _ = graphic_record . plot ( figure_width = figure_width , ** kwargs ) return ax Methods compute_feature_box_color def compute_feature_box_color ( self , feature ) Compute a box_color for this feature. View Source def compute_feature_box_color(self, feature): \"\"\"Compute a box_color for this feature.\"\"\" return \"auto\" compute_feature_box_linewidth def compute_feature_box_linewidth ( self , feature ) Compute a box_linewidth for this feature. View Source def compute_feature_box_linewidth(self, feature): \"\"\"Compute a box_linewidth for this feature.\"\"\" return 0.3 compute_feature_color def compute_feature_color ( self , feature ) Compute a color for this feature. If the feature has a color qualifier it will be used. Otherwise, the classe's default_feature_color is used. To change the behaviour, create a subclass of BiopythonTranslator and overwrite this method. View Source def compute_feature_color ( self , feature ) : status = \"status\" # Values are from binarize_bed () : if feature . qualifiers [ status ] == \"1\" : return \"red\" elif feature . qualifiers [ status ] == \"U\" : return \"yellow\" elif feature . qualifiers [ status ] == \"0\" : return \"grey\" # to be implemented later : elif feature . qualifiers [ status ] == \"?\" : return \"tab:cyan\" # There should be no other options . compute_feature_fontdict def compute_feature_fontdict ( self , feature ) Compute a font dict for this feature. View Source def compute_feature_fontdict(self, feature): \"\"\"Compute a font dict for this feature.\"\"\" return None compute_feature_html def compute_feature_html ( self , feature ) Gets the 'label' of the feature. View Source def compute_feature_html(self, feature): \"\"\"Gets the 'label' of the feature.\"\"\" return self.compute_feature_label(feature) compute_feature_label def compute_feature_label ( self , feature ) Compute the label of the feature. View Source def compute_feature_label ( self , feature ) : \"\"\"Compute the label of the feature.\"\"\" label = feature . type for key in self . label_fields : if key in feature . qualifiers and len ( feature . qualifiers [ key ] ) : label = feature . qualifiers [ key ] break if isinstance ( label , list ) : label = \"|\" . join ( label ) return label compute_feature_label_link_color def compute_feature_label_link_color ( self , feature ) Compute the color of the line linking the label to its feature. View Source def compute_feature_label_link_color(self, feature): \"\"\"Compute the color of the line linking the label to its feature.\"\"\" return \"black\" compute_feature_legend_text def compute_feature_legend_text ( self , feature ) View Source def compute_feature_legend_text(self, feature): return None compute_feature_linewidth def compute_feature_linewidth ( self , feature ) Compute the edge width of the feature's arrow/rectangle. View Source def compute_feature_linewidth(self, feature): \"\"\"Compute the edge width of the feature's arrow/rectangle.\"\"\" return 1.0 compute_filtered_features def compute_filtered_features ( self , features ) Return the list of features minus the ignored ones. By the method keeps any feature whose type is not in ignored_features_types and for which all filter(f) pass. View Source def compute_filtered_features ( self , features ): \"\"\"Return the list of features minus the ignored ones. By the method keeps any feature whose type is not in ignored_features_types and for which all filter(f) pass. \"\"\" return [ f for f in features if all ([ fl ( f ) for fl in self . features_filters ]) and f . type not in self . ignored_features_types ] quick_plot def quick_plot ( self , record , figure_width = 12 , ** kwargs ) Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. from dna_features_viewer import BiopythonTranslator BiopythonTranslator.quick_plot(my_record) View Source def quick_plot ( self , record , figure_width = 12 , ** kwargs ): \"\"\"Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. >>> from dna_features_viewer import BiopythonTranslator >>> BiopythonTranslator.quick_plot(my_record) \"\"\" graphic_record = self . translate_record ( record ) ax , _ = graphic_record . plot ( figure_width = figure_width , ** kwargs ) return ax translate_feature def translate_feature ( self , feature ) Translate a Biopython feature into a Dna Features Viewer feature. View Source def translate_feature(self, feature): \"\"\"Translate a Biopython feature into a Dna Features Viewer feature.\"\"\" properties = dict( label=self.compute_feature_label(feature), color=self.compute_feature_color(feature), html=self.compute_feature_html(feature), fontdict=self.compute_feature_fontdict(feature), box_linewidth=self.compute_feature_box_linewidth(feature), box_color=self.compute_feature_box_color(feature), linewidth=self.compute_feature_linewidth(feature), label_link_color=self.compute_feature_label_link_color(feature), legend_text=self.compute_feature_legend_text(feature), ) if self.features_properties is not None: other_properties = self.features_properties if hasattr(other_properties, \"__call__\"): other_properties = other_properties(feature) properties.update(other_properties) return GraphicFeature( start=feature.location.start, end=feature.location.end, strand=feature.location.strand, **properties ) translate_record def translate_record ( self , record , record_class = None , filetype = None ) Create a new GraphicRecord from a BioPython Record object. Parameters: Name Type Description Default record None A BioPython Record object or the path to a Genbank or a GFF file. None record_class None The graphic record class to use, e.g. GraphicRecord (default) or CircularGraphicRecord. Strings 'circular' and 'linear' can also be provided. None filetype None Used only when a Genbank or a GFF file is provided; one of \"genbank\" or \"gff\" to be used. Default None infers from file extension. None View Source def translate_record ( self , record , record_class = None , filetype = None ) : \"\"\"Create a new GraphicRecord from a BioPython Record object. Parameters ---------- record A BioPython Record object or the path to a Genbank or a GFF file. record_class The graphic record class to use, e.g. GraphicRecord (default) or CircularGraphicRecord. Strings 'circular' and 'linear' can also be provided. filetype Used only when a Genbank or a GFF file is provided; one of \" genbank \" or \" gff \" to be used. Default None infers from file extension. \"\"\" classes = { \"linear\" : GraphicRecord , \"circular\" : CircularGraphicRecord , None : GraphicRecord , } if record_class in classes : record_class = classes [ record_class ] if isinstance ( record , str ) or hasattr ( record , \"read\" ) : record = load_record ( record , filetype = filetype ) filtered_features = self . compute_filtered_features ( record . features ) return record_class ( sequence_length = len ( record ), sequence = str ( record . seq ) if record . seq . defined else None , features =[ self.translate_feature(feature) for feature in filtered_features if feature.location is not None ] , ** self . graphic_record_parameters )","title":"Bedmethyl"},{"location":"reference/epijinn/Bedmethyl/#module-epijinnbedmethyl","text":"View Source # Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh # # This file is part of EpiJinn. # # EpiJinn is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. # # EpiJinn is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. # # You should have received a copy of the GNU General Public License along with Ediacara. If not, see <https://www.gnu.org/licenses/>. import copy import os import pandas import matplotlib.pyplot as plt import Bio import dna_features_viewer from .Methyl import METHYLASES from .Methyl import annotate_methylation COMPLEMENTS = { \"A\" : \"T\" , \"C\" : \"G\" , \"G\" : \"C\" , \"T\" : \"A\" , } # From https://github.com/nanoporetech/modkit/blob/master/book/src/intro_bedmethyl.md BEDMETHYL_HEADER = [ \"chrom\" , \"start_position\" , \"end_position\" , \"modified_base_code_and_motif\" , \"score\" , \"strand\" , \"strand_start_position\" , \"strand_end_position\" , \"color\" , \"Nvalid_cov\" , \"percent_modified\" , \"Nmod\" , \"Ncanonical\" , \"Nother_mod\" , \"Ndelete\" , \"Nfail\" , \"Ndiff\" , \"Nnocall\" , ] # Remove duplicate and unnecessary columns from report: columns_for_pdf_report = [ BEDMETHYL_HEADER [ i ] for i in [ 1 , 5 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 ] ] + [ \"status\" ] # added during binarization DATA_DIR = os . path . join ( os . path . dirname ( os . path . realpath ( __file__ )), \"data\" ) # For looking up modified_base_code_and_motif entries in bedmethyl: MODIFICATION_CODES = pandas . read_csv ( os . path . join ( DATA_DIR , \"mod_base_codes.csv\" )) # Adapted From https://github.com/samtools/hts-specs/blob/master/SAMtags.pdf class CustomTranslator ( dna_features_viewer . BiopythonTranslator ): \"\"\"Custom translator used for the main plot.\"\"\" def compute_filtered_features ( self , features ): \"\"\"Display only selected features.\"\"\" filtered_features = [] n = 8 # a good number of features to display # Keep longest features if len ( features ) > n : feature_lengths = [] for feature in features : feature_lengths += [ len ( feature . location )] feature_lengths . sort ( reverse = True ) max_length = feature_lengths [ n ] for feature in features : if len ( feature . location ) > max_length : filtered_features += [ feature ] else : # no need to do anything if not enough features filtered_features = features return filtered_features class PatternTranslator ( dna_features_viewer . BiopythonTranslator ): \"\"\"Custom translator used for the pattern annotation plot.\"\"\" def compute_feature_color ( self , feature ): status = \"status\" # Values are from binarize_bed() : if feature . qualifiers [ status ] == \"1\" : return \"red\" elif feature . qualifiers [ status ] == \"U\" : return \"yellow\" elif feature . qualifiers [ status ] == \"0\" : return \"grey\" # to be implemented later: elif feature . qualifiers [ status ] == \"?\" : return \"tab:cyan\" # There should be no other options. class BedResult : \"\"\"Results of a bedmethyl table analysis.\"\"\" def __init__ ( self , modification , bed , record ): self . feature_cutoff = 50 # do not create a plot if there are more features self . modification = modification self . mod_abbreviation = MODIFICATION_CODES . loc [ MODIFICATION_CODES [ \"Code\" ] == self . modification ] . Abbreviation . iloc [ 0 ] # there is only one entry so we take the first self . mod_name = MODIFICATION_CODES . loc [ MODIFICATION_CODES [ \"Code\" ] == self . modification ] . Name . iloc [ 0 ] self . mod_chebi = MODIFICATION_CODES . loc [ MODIFICATION_CODES [ \"Code\" ] == self . modification ] . ChEBI . iloc [ 0 ] self . unmodified_base = MODIFICATION_CODES . loc [ MODIFICATION_CODES [ \"Code\" ] == self . modification ] . Unmodified_base . iloc [ 0 ] self . bed = bed self . record = record # FILTER (ANNOTATED) RECORD AND ADD STATUS: filtered_features = [] labelstart = ( \"@epijinn(\" + self . unmodified_base + \", strand=\" ) # unfinished to account for +/- strands for feature in record . features : if feature . id == \"@epijinn\" : # as annotated by the function if feature . qualifiers [ \"label\" ] . startswith ( labelstart ): # To display seq in report: feature . qualifiers [ \"label\" ] = self . unmodified_base # Assign status: # no need to check for strand as the complement won't be modified location_start = int ( feature . location . start ) # expect exactly one bed table entry per modified nucleotide: status_symbol = self . bed . loc [ self . bed [ \"LOC\" ] == location_start ] . STATUS . iloc [ 0 ] # used by a custom BiopythonTranslator to colour the annotation: feature . qualifiers [ \"status\" ] = status_symbol filtered_features += [ feature ] record . features = filtered_features if len ( self . record . features ) > self . feature_cutoff : self . img_created = False else : self . img_created = True fig , ax1 = plt . subplots ( 1 , 1 , figsize = ( 8 , 3 )) graphic_record = PatternTranslator () . translate_record ( self . record ) graphic_record . plot ( ax = ax1 , with_ruler = False , strand_in_label_threshold = 4 ) self . plot = fig class BedmethylItem : \"\"\"Analyse a bedmethyl file. **Parameters** **sample** > The name of the sample, for example a barcode id (`str`). **reference** > A Biopython SeqRecord. **bedmethyl** > A pandas dataframe of a bedmethyl file for the reference. \"\"\" def __init__ ( self , sample , reference , bedmethyl ): self . sample = sample self . record = reference self . name = reference . name self . id = reference . id self . bed = bedmethyl self . reference_length = len ( self . record ) def perform_analysis ( self , parameter_dict ): \"\"\"Perform analysis and plot the sequence.\"\"\" methylase_str = parameter_dict [ \"methylases\" ] methylase = METHYLASES [ methylase_str ] self . fig = self . plot_record () self . results = [] # BedResult instances. For easy reference in pug template. for modification in self . bed . modified_base_code_and_motif . unique (): # RUN BED SUBSET ETC bed_subtype = self . subset_bed_to_mod_subtype ( self . bed , mod = modification ) annotated_record , bed_pattern_match = self . subset_bed_to_pattern_match ( methylase , bed = bed_subtype ) bed_binarized = self . binarize_bed ( bed_pattern_match , met_cutoff = parameter_dict [ \"methylated_cutoff\" ], nonmet_cutoff = parameter_dict [ \"unmethylated_cutoff\" ], ) final_bed = subset_bed_columns ( bed_binarized ) bedresult = BedResult ( modification , bed = final_bed , record = annotated_record ) self . results += [ bedresult ] def annotate_record ( self ): return self . record def plot_record ( self ): fig , ax1 = plt . subplots ( 1 , 1 , figsize = ( 8 , 2 )) graphic_record = CustomTranslator () . translate_record ( self . record ) graphic_record . plot ( ax = ax1 , with_ruler = False , strand_in_label_threshold = 4 ) return fig @staticmethod def subset_bed_to_mod_subtype ( bed , mod ): # Columnname from Bedmethyl file specification bed_subtype = bed . loc [ bed [ \"modified_base_code_and_motif\" ] == mod ] return bed_subtype def subset_bed_to_base_matches ( self , bed = None , modified_base = \"C\" ): if bed is None : # optional bed allows linking multiple bed subset methods bed = self . bed mod_base = modified_base . upper () mod_base_complement = COMPLEMENTS [ mod_base ] # POSITIVE STRAND matching_positions_on_positive_strand = [ pos for pos , base in enumerate ( str ( self . record . seq . upper ())) if base == mod_base ] # Columnname from Bedmethyl file specification: positive_strand_filter = bed [ \"start_position\" ] . isin ( matching_positions_on_positive_strand ) & ( bed [ \"strand\" ] == \"+\" ) # NEGATIVE STRAND matching_positions_on_negative_strand = [ pos for pos , base in enumerate ( str ( self . record . seq . upper ())) if base == mod_base_complement ] negative_strand_filter = bed [ \"start_position\" ] . isin ( matching_positions_on_negative_strand ) & ( bed [ \"strand\" ] == \"-\" ) bed_basematch = bed . loc [ positive_strand_filter | negative_strand_filter ] return bed_basematch def subset_bed_to_pattern_match ( self , methylase , bed = None ): if bed is None : # optional bed allows linking multiple bed subset methods bed = self . bed methylated_index = methylase . index_pos mod_base = methylase . sequence [ methylated_index ] . upper () record_copy = copy . deepcopy ( self . record ) annotated_record = annotate_methylation ( record_copy , methylases = [ methylase ]) # CREATE LIST OF POSITIONS positive_strand_locations = [] negative_strand_locations = [] label_pos = \"@epijinn(\" + mod_base + \", strand=1)\" label_neg = \"@epijinn(\" + mod_base + \", strand=-1)\" for feature in annotated_record . features : if feature . id == \"@epijinn\" : # as annotated by function above if feature . qualifiers [ \"label\" ] == label_pos : positive_strand_locations += [ feature . location . start ] elif feature . qualifiers [ \"label\" ] == label_neg : negative_strand_locations += [ feature . location . start ] # SUBSET USING POSITIONS # Columnname from Bedmethyl file specification: positive_strand_filter = bed [ \"start_position\" ] . isin ( positive_strand_locations ) & ( bed [ \"strand\" ] == \"+\" ) negative_strand_filter = bed [ \"start_position\" ] . isin ( negative_strand_locations ) & ( bed [ \"strand\" ] == \"-\" ) bed_pattern_match = bed . loc [ positive_strand_filter | negative_strand_filter ] return annotated_record , bed_pattern_match @staticmethod def binarize_bed ( bed , met_cutoff , nonmet_cutoff ): bed [ \"status\" ] = \"U\" # prefill undetermined for index , row in bed . iterrows (): if row [ \"percent_modified\" ] >= float ( met_cutoff ) * 100 : bed . loc [ index , \"status\" ] = \"1\" # methylated, symbol may change elif row [ \"percent_modified\" ] <= float ( nonmet_cutoff ) * 100 : bed . loc [ index , \"status\" ] = \"0\" # unmethylated # symbol \"?\" reserved for low coverage to be implemented later return bed def read_sample_sheet ( sample_sheet , genbank_dir = \"\" , bedmethyl_dir = \"\" , parameter_sheet = \"\" ): \"\"\"Read a sample sheet into a BedmethylItemGroup. **Parameters** **sample_sheet** > CSV file path (`str`). No header and columns must be in this order: projectname, sample, Genbank name (without extension), bedmethyl file. **genbank_dir** > Directory of the Genbank files (`str`). Default: local directory. **bedmethyl_dir** > Directory of the bedmethyl files (`str`). Default: local directory. **parameter_sheet** > CSV file path (`str`). Use 'Parameter', 'Value' header for columns. If a 'projectname' is specified, it overwrites the sample sheet value. \"\"\" # READ PARAMETERS param_df = pandas . read_csv ( parameter_sheet , usecols = [ \"Parameter\" , \"Value\" ]) parameter_dict = dict ( param_df . values ) # READ SAMPLES sample_df = pandas . read_csv ( sample_sheet , header = None ) # add columnnames # CREATE ITEMS # We allow Sequeduct to specify the projectname as a command parameter as well; if not \"projectname\" in parameter_dict : # first entry of the first column (contains projectname): parameter_dict [ \"projectname\" ] = sample_df . iloc [ 0 , 0 ] # Allow the user to not specify these in the sheet: # The default cutoffs are based on preliminary data. if not \"methylated_cutoff\" in parameter_dict : parameter_dict [ \"methylated_cutoff\" ] = 0.7 if not \"unmethylated_cutoff\" in parameter_dict : parameter_dict [ \"unmethylated_cutoff\" ] = 0.3 bedmethylitems = [] for index , row in sample_df . iterrows (): genbank_name = row [ 2 ] # number specified by the sample sheet format genbank_path = os . path . join ( genbank_dir , genbank_name + \".gb\" ) # Genbank ext record = Bio . SeqIO . read ( genbank_path , \"genbank\" ) record . id = genbank_name record . name = genbank_name record . annotations [ \"molecule_type\" ] = \"DNA\" bed_name = row [ 3 ] # number specified by the sample sheet format bed_path = os . path . join ( bedmethyl_dir , bed_name ) bed_df = pandas . read_csv ( bed_path , header = None , delimiter = \" \\t \" ) bed_df . columns = BEDMETHYL_HEADER bedmethylitems += [ BedmethylItem ( sample = row [ 1 ], reference = record , bedmethyl = bed_df ) ] # number specified by the sample sheet format bedmethylitemgroup = BedmethylItemGroup ( bedmethylitems = bedmethylitems , parameter_dict = parameter_dict ) return bedmethylitemgroup def subset_bed_columns ( bed ): bed_report = bed [ columns_for_pdf_report ] # These were designed to be more informative and fit the report: new_columnnames = [ \"LOC\" , \"Strand\" , \"COV\" , \"% mod\" , \"MOD\" , \"STD\" , \"OTH\" , \"del\" , \"fail\" , \"diff\" , \"nocall\" , \"STATUS\" , ] bed_report . columns = new_columnnames return bed_report class BedmethylItemGroup : \"\"\"A group of BedmethylItem instances for reporting. **Parameters** **bedmethylitems** > A list of BedmethylItem instances. **parameter_dict** > A dictionary of analysis parameters (`dict`). \"\"\" def __init__ ( self , bedmethylitems , parameter_dict ): self . bedmethylitems = bedmethylitems self . parameter_dict = parameter_dict self . number_of_samples = len ( bedmethylitems ) def perform_all_analysis_in_bedmethylitemgroup ( self ): for bedmethylitem in self . bedmethylitems : bedmethylitem . perform_analysis ( parameter_dict = self . parameter_dict ) self . comparisons_performed = True","title":"Module epijinn.Bedmethyl"},{"location":"reference/epijinn/Bedmethyl/#variables","text":"BEDMETHYL_HEADER COMPLEMENTS DATA_DIR METHYLASES MODIFICATION_CODES columns_for_pdf_report","title":"Variables"},{"location":"reference/epijinn/Bedmethyl/#functions","text":"","title":"Functions"},{"location":"reference/epijinn/Bedmethyl/#read_sample_sheet","text":"def read_sample_sheet ( sample_sheet , genbank_dir = '' , bedmethyl_dir = '' , parameter_sheet = '' ) Read a sample sheet into a BedmethylItemGroup. Parameters sample_sheet CSV file path ( str ). No header and columns must be in this order: projectname, sample, Genbank name (without extension), bedmethyl file. genbank_dir Directory of the Genbank files ( str ). Default: local directory. bedmethyl_dir Directory of the bedmethyl files ( str ). Default: local directory. parameter_sheet CSV file path ( str ). Use 'Parameter', 'Value' header for columns. If a 'projectname' is specified, it overwrites the sample sheet value. View Source def read_sample_sheet ( sample_sheet , genbank_dir = \"\" , bedmethyl_dir = \"\" , parameter_sheet = \"\" ) : \" \"\" Read a sample sheet into a BedmethylItemGroup. **Parameters** **sample_sheet** > CSV file path (`str`). No header and columns must be in this order: projectname, sample, Genbank name (without extension), bedmethyl file. **genbank_dir** > Directory of the Genbank files (`str`). Default: local directory. **bedmethyl_dir** > Directory of the bedmethyl files (`str`). Default: local directory. **parameter_sheet** > CSV file path (`str`). Use 'Parameter', 'Value' header for columns. If a 'projectname' is specified, it overwrites the sample sheet value. \"\" \" # READ PARAMETERS param_df = pandas . read_csv ( parameter_sheet , usecols = [ \"Parameter\" , \"Value\" ] ) parameter_dict = dict ( param_df . values ) # READ SAMPLES sample_df = pandas . read_csv ( sample_sheet , header = None ) # add columnnames # CREATE ITEMS # We allow Sequeduct to specify the projectname as a command parameter as well; if not \"projectname\" in parameter_dict : # first entry of the first column (contains projectname): parameter_dict [ \"projectname\" ] = sample_df . iloc [ 0 , 0 ] # Allow the user to not specify these in the sheet: # The default cutoffs are based on preliminary data. if not \"methylated_cutoff\" in parameter_dict : parameter_dict [ \"methylated_cutoff\" ] = 0.7 if not \"unmethylated_cutoff\" in parameter_dict : parameter_dict [ \"unmethylated_cutoff\" ] = 0.3 bedmethylitems = [] for index , row in sample_df . iterrows () : genbank_name = row [ 2 ] # number specified by the sample sheet format genbank_path = os . path . join ( genbank_dir , genbank_name + \".gb\" ) # Genbank ext record = Bio . SeqIO . read ( genbank_path , \"genbank\" ) record . id = genbank_name record . name = genbank_name record . annotations [ \"molecule_type\" ] = \"DNA\" bed_name = row [ 3 ] # number specified by the sample sheet format bed_path = os . path . join ( bedmethyl_dir , bed_name ) bed_df = pandas . read_csv ( bed_path , header = None , delimiter = \" \\t \" ) bed_df . columns = BEDMETHYL_HEADER bedmethylitems += [ BedmethylItem ( sample = row [ 1 ] , reference = record , bedmethyl = bed_df ) ] # number specified by the sample sheet format bedmethylitemgroup = BedmethylItemGroup ( bedmethylitems = bedmethylitems , parameter_dict = parameter_dict ) return bedmethylitemgroup","title":"read_sample_sheet"},{"location":"reference/epijinn/Bedmethyl/#subset_bed_columns","text":"def subset_bed_columns ( bed ) View Source def subset_bed_columns ( bed ) : bed_report = bed [ columns_for_pdf_report ] # These were designed to be more informative and fit the report : new_columnnames = [ \"LOC\", \"Strand\", \"COV\", \"% mod\", \"MOD\", \"STD\", \"OTH\", \"del\", \"fail\", \"diff\", \"nocall\", \"STATUS\", ] bed_report . columns = new_columnnames return bed_report","title":"subset_bed_columns"},{"location":"reference/epijinn/Bedmethyl/#classes","text":"","title":"Classes"},{"location":"reference/epijinn/Bedmethyl/#bedresult","text":"class BedResult ( modification , bed , record ) Results of a bedmethyl table analysis. View Source class BedResult : \"\"\"Results of a bedmethyl table analysis.\"\"\" def __init__ ( self , modification , bed , record ) : self . feature_cutoff = 50 # do not create a plot if there are more features self . modification = modification self . mod_abbreviation = MODIFICATION_CODES . loc [ MODIFICATION_CODES[\"Code\" ] == self . modification ] . Abbreviation . iloc [ 0 ] # there is only one entry so we take the first self . mod_name = MODIFICATION_CODES . loc [ MODIFICATION_CODES[\"Code\" ] == self . modification ] . Name . iloc [ 0 ] self . mod_chebi = MODIFICATION_CODES . loc [ MODIFICATION_CODES[\"Code\" ] == self . modification ] . ChEBI . iloc [ 0 ] self . unmodified_base = MODIFICATION_CODES . loc [ MODIFICATION_CODES[\"Code\" ] == self . modification ] . Unmodified_base . iloc [ 0 ] self . bed = bed self . record = record # FILTER ( ANNOTATED ) RECORD AND ADD STATUS : filtered_features = [] labelstart = ( \"@epijinn(\" + self . unmodified_base + \", strand=\" ) # unfinished to account for +/- strands for feature in record . features : if feature . id == \"@epijinn\" : # as annotated by the function if feature . qualifiers [ \"label\" ] . startswith ( labelstart ) : # To display seq in report : feature . qualifiers [ \"label\" ] = self . unmodified_base # Assign status : # no need to check for strand as the complement won ' t be modified location_start = int ( feature . location . start ) # expect exactly one bed table entry per modified nucleotide : status_symbol = self . bed . loc [ self.bed[\"LOC\" ] == location_start ] . STATUS . iloc [ 0 ] # used by a custom BiopythonTranslator to colour the annotation : feature . qualifiers [ \"status\" ] = status_symbol filtered_features += [ feature ] record . features = filtered_features if len ( self . record . features ) > self . feature_cutoff : self . img_created = False else : self . img_created = True fig , ax1 = plt . subplots ( 1 , 1 , figsize = ( 8 , 3 )) graphic_record = PatternTranslator (). translate_record ( self . record ) graphic_record . plot ( ax = ax1 , with_ruler = False , strand_in_label_threshold = 4 ) self . plot = fig","title":"BedResult"},{"location":"reference/epijinn/Bedmethyl/#bedmethylitem","text":"class BedmethylItem ( sample , reference , bedmethyl ) Analyse a bedmethyl file. Parameters sample The name of the sample, for example a barcode id ( str ). reference A Biopython SeqRecord. bedmethyl A pandas dataframe of a bedmethyl file for the reference. View Source class BedmethylItem : \"\"\"Analyse a bedmethyl file. **Parameters** **sample** > The name of the sample, for example a barcode id (`str`). **reference** > A Biopython SeqRecord. **bedmethyl** > A pandas dataframe of a bedmethyl file for the reference. \"\"\" def __init__ ( self , sample , reference , bedmethyl ) : self . sample = sample self . record = reference self . name = reference . name self . id = reference . id self . bed = bedmethyl self . reference_length = len ( self . record ) def perform_analysis ( self , parameter_dict ) : \"\"\"Perform analysis and plot the sequence.\"\"\" methylase_str = parameter_dict [ \"methylases\" ] methylase = METHYLASES [ methylase_str ] self . fig = self . plot_record () self . results = [] # BedResult instances . For easy reference in pug template . for modification in self . bed . modified_base_code_and_motif . unique () : # RUN BED SUBSET ETC bed_subtype = self . subset_bed_to_mod_subtype ( self . bed , mod = modification ) annotated_record , bed_pattern_match = self . subset_bed_to_pattern_match ( methylase , bed = bed_subtype ) bed_binarized = self . binarize_bed ( bed_pattern_match , met_cutoff = parameter_dict [ \"methylated_cutoff\" ] , nonmet_cutoff = parameter_dict [ \"unmethylated_cutoff\" ] , ) final_bed = subset_bed_columns ( bed_binarized ) bedresult = BedResult ( modification , bed = final_bed , record = annotated_record ) self . results += [ bedresult ] def annotate_record ( self ) : return self . record def plot_record ( self ) : fig , ax1 = plt . subplots ( 1 , 1 , figsize = ( 8 , 2 )) graphic_record = CustomTranslator (). translate_record ( self . record ) graphic_record . plot ( ax = ax1 , with_ruler = False , strand_in_label_threshold = 4 ) return fig @staticmethod def subset_bed_to_mod_subtype ( bed , mod ) : # Columnname from Bedmethyl file specification bed_subtype = bed . loc [ bed[\"modified_base_code_and_motif\" ] == mod ] return bed_subtype def subset_bed_to_base_matches ( self , bed = None , modified_base = \"C\" ) : if bed is None : # optional bed allows linking multiple bed subset methods bed = self . bed mod_base = modified_base . upper () mod_base_complement = COMPLEMENTS [ mod_base ] # POSITIVE STRAND matching_positions_on_positive_strand = [ pos for pos, base in enumerate(str(self.record.seq.upper())) if base == mod_base ] # Columnname from Bedmethyl file specification : positive_strand_filter = bed [ \"start_position\" ] . isin ( matching_positions_on_positive_strand ) & ( bed [ \"strand\" ] == \"+\" ) # NEGATIVE STRAND matching_positions_on_negative_strand = [ pos for pos, base in enumerate(str(self.record.seq.upper())) if base == mod_base_complement ] negative_strand_filter = bed [ \"start_position\" ] . isin ( matching_positions_on_negative_strand ) & ( bed [ \"strand\" ] == \"-\" ) bed_basematch = bed . loc [ positive_strand_filter | negative_strand_filter ] return bed_basematch def subset_bed_to_pattern_match ( self , methylase , bed = None ) : if bed is None : # optional bed allows linking multiple bed subset methods bed = self . bed methylated_index = methylase . index_pos mod_base = methylase . sequence [ methylated_index ] . upper () record_copy = copy . deepcopy ( self . record ) annotated_record = annotate_methylation ( record_copy , methylases =[ methylase ] ) # CREATE LIST OF POSITIONS positive_strand_locations = [] negative_strand_locations = [] label_pos = \"@epijinn(\" + mod_base + \", strand=1)\" label_neg = \"@epijinn(\" + mod_base + \", strand=-1)\" for feature in annotated_record . features : if feature . id == \"@epijinn\" : # as annotated by function above if feature . qualifiers [ \"label\" ] == label_pos : positive_strand_locations += [ feature.location.start ] elif feature . qualifiers [ \"label\" ] == label_neg : negative_strand_locations += [ feature.location.start ] # SUBSET USING POSITIONS # Columnname from Bedmethyl file specification : positive_strand_filter = bed [ \"start_position\" ] . isin ( positive_strand_locations ) & ( bed [ \"strand\" ] == \"+\" ) negative_strand_filter = bed [ \"start_position\" ] . isin ( negative_strand_locations ) & ( bed [ \"strand\" ] == \"-\" ) bed_pattern_match = bed . loc [ positive_strand_filter | negative_strand_filter ] return annotated_record , bed_pattern_match @staticmethod def binarize_bed ( bed , met_cutoff , nonmet_cutoff ) : bed [ \"status\" ] = \"U\" # prefill undetermined for index , row in bed . iterrows () : if row [ \"percent_modified\" ] >= float ( met_cutoff ) * 100 : bed . loc [ index, \"status\" ] = \"1\" # methylated , symbol may change elif row [ \"percent_modified\" ] <= float ( nonmet_cutoff ) * 100 : bed . loc [ index, \"status\" ] = \"0\" # unmethylated # symbol \"?\" reserved for low coverage to be implemented later return bed","title":"BedmethylItem"},{"location":"reference/epijinn/Bedmethyl/#static-methods","text":"","title":"Static methods"},{"location":"reference/epijinn/Bedmethyl/#binarize_bed","text":"def binarize_bed ( bed , met_cutoff , nonmet_cutoff ) View Source @ staticmethod def binarize_bed ( bed , met_cutoff , nonmet_cutoff ): bed [ \"status\" ] = \"U\" # prefill undetermined for index , row in bed . iterrows (): if row [ \"percent_modified\" ] >= float ( met_cutoff ) * 100 : bed . loc [ index , \"status\" ] = \"1\" # methylated , symbol may change elif row [ \"percent_modified\" ] <= float ( nonmet_cutoff ) * 100 : bed . loc [ index , \"status\" ] = \"0\" # unmethylated # symbol \"?\" reserved for low coverage to be implemented later return bed","title":"binarize_bed"},{"location":"reference/epijinn/Bedmethyl/#subset_bed_to_mod_subtype","text":"def subset_bed_to_mod_subtype ( bed , mod ) View Source @ staticmethod def subset_bed_to_mod_subtype ( bed , mod ): # Columnname from Bedmethyl file specification bed_subtype = bed . loc [ bed [ \"modified_base_code_and_motif\" ] == mod ] return bed_subtype","title":"subset_bed_to_mod_subtype"},{"location":"reference/epijinn/Bedmethyl/#methods","text":"","title":"Methods"},{"location":"reference/epijinn/Bedmethyl/#annotate_record","text":"def annotate_record ( self ) View Source def annotate_record(self): return self.record","title":"annotate_record"},{"location":"reference/epijinn/Bedmethyl/#perform_analysis","text":"def perform_analysis ( self , parameter_dict ) Perform analysis and plot the sequence. View Source def perform_analysis ( self , parameter_dict ) : \"\"\"Perform analysis and plot the sequence.\"\"\" methylase_str = parameter_dict [ \"methylases\" ] methylase = METHYLASES [ methylase_str ] self . fig = self . plot_record () self . results = [] # BedResult instances . For easy reference in pug template . for modification in self . bed . modified_base_code_and_motif . unique () : # RUN BED SUBSET ETC bed_subtype = self . subset_bed_to_mod_subtype ( self . bed , mod = modification ) annotated_record , bed_pattern_match = self . subset_bed_to_pattern_match ( methylase , bed = bed_subtype ) bed_binarized = self . binarize_bed ( bed_pattern_match , met_cutoff = parameter_dict [ \"methylated_cutoff\" ] , nonmet_cutoff = parameter_dict [ \"unmethylated_cutoff\" ] , ) final_bed = subset_bed_columns ( bed_binarized ) bedresult = BedResult ( modification , bed = final_bed , record = annotated_record ) self . results += [ bedresult ]","title":"perform_analysis"},{"location":"reference/epijinn/Bedmethyl/#plot_record","text":"def plot_record ( self ) View Source def plot_record(self): fig, ax1 = plt.subplots(1, 1, figsize=(8, 2)) graphic_record = CustomTranslator().translate_record(self.record) graphic_record.plot(ax=ax1, with_ruler=False, strand_in_label_threshold=4) return fig","title":"plot_record"},{"location":"reference/epijinn/Bedmethyl/#subset_bed_to_base_matches","text":"def subset_bed_to_base_matches ( self , bed = None , modified_base = 'C' ) View Source def subset_bed_to_base_matches ( self , bed = None , modified_base = \"C\" ) : if bed is None : # optional bed allows linking multiple bed subset methods bed = self . bed mod_base = modified_base . upper () mod_base_complement = COMPLEMENTS [ mod_base ] # POSITIVE STRAND matching_positions_on_positive_strand = [ pos for pos, base in enumerate(str(self.record.seq.upper())) if base == mod_base ] # Columnname from Bedmethyl file specification : positive_strand_filter = bed [ \"start_position\" ] . isin ( matching_positions_on_positive_strand ) & ( bed [ \"strand\" ] == \"+\" ) # NEGATIVE STRAND matching_positions_on_negative_strand = [ pos for pos, base in enumerate(str(self.record.seq.upper())) if base == mod_base_complement ] negative_strand_filter = bed [ \"start_position\" ] . isin ( matching_positions_on_negative_strand ) & ( bed [ \"strand\" ] == \"-\" ) bed_basematch = bed . loc [ positive_strand_filter | negative_strand_filter ] return bed_basematch","title":"subset_bed_to_base_matches"},{"location":"reference/epijinn/Bedmethyl/#subset_bed_to_pattern_match","text":"def subset_bed_to_pattern_match ( self , methylase , bed = None ) View Source def subset_bed_to_pattern_match ( self , methylase , bed = None ) : if bed is None : # optional bed allows linking multiple bed subset methods bed = self . bed methylated_index = methylase . index_pos mod_base = methylase . sequence [ methylated_index ] . upper () record_copy = copy . deepcopy ( self . record ) annotated_record = annotate_methylation ( record_copy , methylases =[ methylase ] ) # CREATE LIST OF POSITIONS positive_strand_locations = [] negative_strand_locations = [] label_pos = \"@epijinn(\" + mod_base + \", strand=1)\" label_neg = \"@epijinn(\" + mod_base + \", strand=-1)\" for feature in annotated_record . features : if feature . id == \"@epijinn\" : # as annotated by function above if feature . qualifiers [ \"label\" ] == label_pos : positive_strand_locations += [ feature.location.start ] elif feature . qualifiers [ \"label\" ] == label_neg : negative_strand_locations += [ feature.location.start ] # SUBSET USING POSITIONS # Columnname from Bedmethyl file specification : positive_strand_filter = bed [ \"start_position\" ] . isin ( positive_strand_locations ) & ( bed [ \"strand\" ] == \"+\" ) negative_strand_filter = bed [ \"start_position\" ] . isin ( negative_strand_locations ) & ( bed [ \"strand\" ] == \"-\" ) bed_pattern_match = bed . loc [ positive_strand_filter | negative_strand_filter ] return annotated_record , bed_pattern_match","title":"subset_bed_to_pattern_match"},{"location":"reference/epijinn/Bedmethyl/#bedmethylitemgroup","text":"class BedmethylItemGroup ( bedmethylitems , parameter_dict ) A group of BedmethylItem instances for reporting. Parameters bedmethylitems A list of BedmethylItem instances. parameter_dict A dictionary of analysis parameters ( dict ). View Source class BedmethylItemGroup : \" \"\" A group of BedmethylItem instances for reporting. **Parameters** **bedmethylitems** > A list of BedmethylItem instances. **parameter_dict** > A dictionary of analysis parameters (`dict`). \"\" \" def __init__ ( self , bedmethylitems , parameter_dict ) : self . bedmethylitems = bedmethylitems self . parameter_dict = parameter_dict self . number_of_samples = len ( bedmethylitems ) def perform_all_analysis_in_bedmethylitemgroup ( self ) : for bedmethylitem in self . bedmethylitems : bedmethylitem . perform_analysis ( parameter_dict = self . parameter_dict ) self . comparisons_performed = True","title":"BedmethylItemGroup"},{"location":"reference/epijinn/Bedmethyl/#methods_1","text":"","title":"Methods"},{"location":"reference/epijinn/Bedmethyl/#perform_all_analysis_in_bedmethylitemgroup","text":"def perform_all_analysis_in_bedmethylitemgroup ( self ) View Source def perform_all_analysis_in_bedmethylitemgroup(self): for bedmethylitem in self.bedmethylitems: bedmethylitem.perform_analysis(parameter_dict=self.parameter_dict) self.comparisons_performed = True","title":"perform_all_analysis_in_bedmethylitemgroup"},{"location":"reference/epijinn/Bedmethyl/#customtranslator","text":"class CustomTranslator ( features_filters = (), features_properties = None ) Custom translator used for the main plot. View Source class CustomTranslator ( dna_features_viewer . BiopythonTranslator ) : \"\"\"Custom translator used for the main plot.\"\"\" def compute_filtered_features ( self , features ) : \"\"\"Display only selected features.\"\"\" filtered_features = [] n = 8 # a good number of features to display # Keep longest features if len ( features ) > n : feature_lengths = [] for feature in features : feature_lengths += [ len(feature.location) ] feature_lengths . sort ( reverse = True ) max_length = feature_lengths [ n ] for feature in features : if len ( feature . location ) > max_length : filtered_features += [ feature ] else : # no need to do anything if not enough features filtered_features = features return filtered_features","title":"CustomTranslator"},{"location":"reference/epijinn/Bedmethyl/#ancestors-in-mro","text":"dna_features_viewer.BiopythonTranslator.BiopythonTranslator.BiopythonTranslator dna_features_viewer.BiopythonTranslator.BiopythonTranslatorBase.BiopythonTranslatorBase","title":"Ancestors (in MRO)"},{"location":"reference/epijinn/Bedmethyl/#class-variables","text":"default_feature_color graphic_record_parameters ignored_features_types label_fields","title":"Class variables"},{"location":"reference/epijinn/Bedmethyl/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/epijinn/Bedmethyl/#quick_class_plot","text":"def quick_class_plot ( record , figure_width = 12 , ** kwargs ) Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. from dna_features_viewer import BiopythonTranslator BiopythonTranslator.quick_plot(my_record) View Source @classmethod def quick_class_plot ( cls , record , figure_width = 12 , ** kwargs ): \"\"\"Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. >>> from dna_features_viewer import BiopythonTranslator >>> BiopythonTranslator.quick_plot(my_record) \"\"\" graphic_record = cls () . translate_record ( record ) ax , _ = graphic_record . plot ( figure_width = figure_width , ** kwargs ) return ax","title":"quick_class_plot"},{"location":"reference/epijinn/Bedmethyl/#methods_2","text":"","title":"Methods"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_box_color","text":"def compute_feature_box_color ( self , feature ) Compute a box_color for this feature. View Source def compute_feature_box_color(self, feature): \"\"\"Compute a box_color for this feature.\"\"\" return \"auto\"","title":"compute_feature_box_color"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_box_linewidth","text":"def compute_feature_box_linewidth ( self , feature ) Compute a box_linewidth for this feature. View Source def compute_feature_box_linewidth(self, feature): \"\"\"Compute a box_linewidth for this feature.\"\"\" return 0.3","title":"compute_feature_box_linewidth"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_color","text":"def compute_feature_color ( self , feature ) Compute a color for this feature. If the feature has a color qualifier it will be used. Otherwise, the classe's default_feature_color is used. To change the behaviour, create a subclass of BiopythonTranslator and overwrite this method. View Source def compute_feature_color ( self , feature ) : \" \"\" Compute a color for this feature. If the feature has a ``color`` qualifier it will be used. Otherwise, the classe's ``default_feature_color`` is used. To change the behaviour, create a subclass of ``BiopythonTranslator`` and overwrite this method. \"\" \" if \"color\" in feature . qualifiers : color = feature . qualifiers [ \"color\" ] if isinstance ( color [ 0 ] , str ) : return \"\" . join ( feature . qualifiers [ \"color\" ] ) else : return color else : return self . default_feature_color","title":"compute_feature_color"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_fontdict","text":"def compute_feature_fontdict ( self , feature ) Compute a font dict for this feature. View Source def compute_feature_fontdict(self, feature): \"\"\"Compute a font dict for this feature.\"\"\" return None","title":"compute_feature_fontdict"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_html","text":"def compute_feature_html ( self , feature ) Gets the 'label' of the feature. View Source def compute_feature_html(self, feature): \"\"\"Gets the 'label' of the feature.\"\"\" return self.compute_feature_label(feature)","title":"compute_feature_html"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_label","text":"def compute_feature_label ( self , feature ) Compute the label of the feature. View Source def compute_feature_label ( self , feature ) : \"\"\"Compute the label of the feature.\"\"\" label = feature . type for key in self . label_fields : if key in feature . qualifiers and len ( feature . qualifiers [ key ] ) : label = feature . qualifiers [ key ] break if isinstance ( label , list ) : label = \"|\" . join ( label ) return label","title":"compute_feature_label"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_label_link_color","text":"def compute_feature_label_link_color ( self , feature ) Compute the color of the line linking the label to its feature. View Source def compute_feature_label_link_color(self, feature): \"\"\"Compute the color of the line linking the label to its feature.\"\"\" return \"black\"","title":"compute_feature_label_link_color"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_legend_text","text":"def compute_feature_legend_text ( self , feature ) View Source def compute_feature_legend_text(self, feature): return None","title":"compute_feature_legend_text"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_linewidth","text":"def compute_feature_linewidth ( self , feature ) Compute the edge width of the feature's arrow/rectangle. View Source def compute_feature_linewidth(self, feature): \"\"\"Compute the edge width of the feature's arrow/rectangle.\"\"\" return 1.0","title":"compute_feature_linewidth"},{"location":"reference/epijinn/Bedmethyl/#compute_filtered_features","text":"def compute_filtered_features ( self , features ) Display only selected features. View Source def compute_filtered_features ( self , features ) : \"\"\"Display only selected features.\"\"\" filtered_features = [] n = 8 # a good number of features to display # Keep longest features if len ( features ) > n : feature_lengths = [] for feature in features : feature_lengths += [ len(feature.location) ] feature_lengths . sort ( reverse = True ) max_length = feature_lengths [ n ] for feature in features : if len ( feature . location ) > max_length : filtered_features += [ feature ] else : # no need to do anything if not enough features filtered_features = features return filtered_features","title":"compute_filtered_features"},{"location":"reference/epijinn/Bedmethyl/#quick_plot","text":"def quick_plot ( self , record , figure_width = 12 , ** kwargs ) Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. from dna_features_viewer import BiopythonTranslator BiopythonTranslator.quick_plot(my_record) View Source def quick_plot ( self , record , figure_width = 12 , ** kwargs ): \"\"\"Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. >>> from dna_features_viewer import BiopythonTranslator >>> BiopythonTranslator.quick_plot(my_record) \"\"\" graphic_record = self . translate_record ( record ) ax , _ = graphic_record . plot ( figure_width = figure_width , ** kwargs ) return ax","title":"quick_plot"},{"location":"reference/epijinn/Bedmethyl/#translate_feature","text":"def translate_feature ( self , feature ) Translate a Biopython feature into a Dna Features Viewer feature. View Source def translate_feature(self, feature): \"\"\"Translate a Biopython feature into a Dna Features Viewer feature.\"\"\" properties = dict( label=self.compute_feature_label(feature), color=self.compute_feature_color(feature), html=self.compute_feature_html(feature), fontdict=self.compute_feature_fontdict(feature), box_linewidth=self.compute_feature_box_linewidth(feature), box_color=self.compute_feature_box_color(feature), linewidth=self.compute_feature_linewidth(feature), label_link_color=self.compute_feature_label_link_color(feature), legend_text=self.compute_feature_legend_text(feature), ) if self.features_properties is not None: other_properties = self.features_properties if hasattr(other_properties, \"__call__\"): other_properties = other_properties(feature) properties.update(other_properties) return GraphicFeature( start=feature.location.start, end=feature.location.end, strand=feature.location.strand, **properties )","title":"translate_feature"},{"location":"reference/epijinn/Bedmethyl/#translate_record","text":"def translate_record ( self , record , record_class = None , filetype = None ) Create a new GraphicRecord from a BioPython Record object. Parameters: Name Type Description Default record None A BioPython Record object or the path to a Genbank or a GFF file. None record_class None The graphic record class to use, e.g. GraphicRecord (default) or CircularGraphicRecord. Strings 'circular' and 'linear' can also be provided. None filetype None Used only when a Genbank or a GFF file is provided; one of \"genbank\" or \"gff\" to be used. Default None infers from file extension. None View Source def translate_record ( self , record , record_class = None , filetype = None ) : \"\"\"Create a new GraphicRecord from a BioPython Record object. Parameters ---------- record A BioPython Record object or the path to a Genbank or a GFF file. record_class The graphic record class to use, e.g. GraphicRecord (default) or CircularGraphicRecord. Strings 'circular' and 'linear' can also be provided. filetype Used only when a Genbank or a GFF file is provided; one of \" genbank \" or \" gff \" to be used. Default None infers from file extension. \"\"\" classes = { \"linear\" : GraphicRecord , \"circular\" : CircularGraphicRecord , None : GraphicRecord , } if record_class in classes : record_class = classes [ record_class ] if isinstance ( record , str ) or hasattr ( record , \"read\" ) : record = load_record ( record , filetype = filetype ) filtered_features = self . compute_filtered_features ( record . features ) return record_class ( sequence_length = len ( record ), sequence = str ( record . seq ) if record . seq . defined else None , features =[ self.translate_feature(feature) for feature in filtered_features if feature.location is not None ] , ** self . graphic_record_parameters )","title":"translate_record"},{"location":"reference/epijinn/Bedmethyl/#patterntranslator","text":"class PatternTranslator ( features_filters = (), features_properties = None ) Custom translator used for the pattern annotation plot. View Source class PatternTranslator ( dna_features_viewer . BiopythonTranslator ) : \"\"\"Custom translator used for the pattern annotation plot.\"\"\" def compute_feature_color ( self , feature ) : status = \"status\" # Values are from binarize_bed () : if feature . qualifiers [ status ] == \"1\" : return \"red\" elif feature . qualifiers [ status ] == \"U\" : return \"yellow\" elif feature . qualifiers [ status ] == \"0\" : return \"grey\" # to be implemented later : elif feature . qualifiers [ status ] == \"?\" : return \"tab:cyan\" # There should be no other options .","title":"PatternTranslator"},{"location":"reference/epijinn/Bedmethyl/#ancestors-in-mro_1","text":"dna_features_viewer.BiopythonTranslator.BiopythonTranslator.BiopythonTranslator dna_features_viewer.BiopythonTranslator.BiopythonTranslatorBase.BiopythonTranslatorBase","title":"Ancestors (in MRO)"},{"location":"reference/epijinn/Bedmethyl/#class-variables_1","text":"default_feature_color graphic_record_parameters ignored_features_types label_fields","title":"Class variables"},{"location":"reference/epijinn/Bedmethyl/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/epijinn/Bedmethyl/#quick_class_plot_1","text":"def quick_class_plot ( record , figure_width = 12 , ** kwargs ) Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. from dna_features_viewer import BiopythonTranslator BiopythonTranslator.quick_plot(my_record) View Source @classmethod def quick_class_plot ( cls , record , figure_width = 12 , ** kwargs ): \"\"\"Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. >>> from dna_features_viewer import BiopythonTranslator >>> BiopythonTranslator.quick_plot(my_record) \"\"\" graphic_record = cls () . translate_record ( record ) ax , _ = graphic_record . plot ( figure_width = figure_width , ** kwargs ) return ax","title":"quick_class_plot"},{"location":"reference/epijinn/Bedmethyl/#methods_3","text":"","title":"Methods"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_box_color_1","text":"def compute_feature_box_color ( self , feature ) Compute a box_color for this feature. View Source def compute_feature_box_color(self, feature): \"\"\"Compute a box_color for this feature.\"\"\" return \"auto\"","title":"compute_feature_box_color"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_box_linewidth_1","text":"def compute_feature_box_linewidth ( self , feature ) Compute a box_linewidth for this feature. View Source def compute_feature_box_linewidth(self, feature): \"\"\"Compute a box_linewidth for this feature.\"\"\" return 0.3","title":"compute_feature_box_linewidth"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_color_1","text":"def compute_feature_color ( self , feature ) Compute a color for this feature. If the feature has a color qualifier it will be used. Otherwise, the classe's default_feature_color is used. To change the behaviour, create a subclass of BiopythonTranslator and overwrite this method. View Source def compute_feature_color ( self , feature ) : status = \"status\" # Values are from binarize_bed () : if feature . qualifiers [ status ] == \"1\" : return \"red\" elif feature . qualifiers [ status ] == \"U\" : return \"yellow\" elif feature . qualifiers [ status ] == \"0\" : return \"grey\" # to be implemented later : elif feature . qualifiers [ status ] == \"?\" : return \"tab:cyan\" # There should be no other options .","title":"compute_feature_color"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_fontdict_1","text":"def compute_feature_fontdict ( self , feature ) Compute a font dict for this feature. View Source def compute_feature_fontdict(self, feature): \"\"\"Compute a font dict for this feature.\"\"\" return None","title":"compute_feature_fontdict"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_html_1","text":"def compute_feature_html ( self , feature ) Gets the 'label' of the feature. View Source def compute_feature_html(self, feature): \"\"\"Gets the 'label' of the feature.\"\"\" return self.compute_feature_label(feature)","title":"compute_feature_html"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_label_1","text":"def compute_feature_label ( self , feature ) Compute the label of the feature. View Source def compute_feature_label ( self , feature ) : \"\"\"Compute the label of the feature.\"\"\" label = feature . type for key in self . label_fields : if key in feature . qualifiers and len ( feature . qualifiers [ key ] ) : label = feature . qualifiers [ key ] break if isinstance ( label , list ) : label = \"|\" . join ( label ) return label","title":"compute_feature_label"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_label_link_color_1","text":"def compute_feature_label_link_color ( self , feature ) Compute the color of the line linking the label to its feature. View Source def compute_feature_label_link_color(self, feature): \"\"\"Compute the color of the line linking the label to its feature.\"\"\" return \"black\"","title":"compute_feature_label_link_color"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_legend_text_1","text":"def compute_feature_legend_text ( self , feature ) View Source def compute_feature_legend_text(self, feature): return None","title":"compute_feature_legend_text"},{"location":"reference/epijinn/Bedmethyl/#compute_feature_linewidth_1","text":"def compute_feature_linewidth ( self , feature ) Compute the edge width of the feature's arrow/rectangle. View Source def compute_feature_linewidth(self, feature): \"\"\"Compute the edge width of the feature's arrow/rectangle.\"\"\" return 1.0","title":"compute_feature_linewidth"},{"location":"reference/epijinn/Bedmethyl/#compute_filtered_features_1","text":"def compute_filtered_features ( self , features ) Return the list of features minus the ignored ones. By the method keeps any feature whose type is not in ignored_features_types and for which all filter(f) pass. View Source def compute_filtered_features ( self , features ): \"\"\"Return the list of features minus the ignored ones. By the method keeps any feature whose type is not in ignored_features_types and for which all filter(f) pass. \"\"\" return [ f for f in features if all ([ fl ( f ) for fl in self . features_filters ]) and f . type not in self . ignored_features_types ]","title":"compute_filtered_features"},{"location":"reference/epijinn/Bedmethyl/#quick_plot_1","text":"def quick_plot ( self , record , figure_width = 12 , ** kwargs ) Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. from dna_features_viewer import BiopythonTranslator BiopythonTranslator.quick_plot(my_record) View Source def quick_plot ( self , record , figure_width = 12 , ** kwargs ): \"\"\"Allows super quick and dirty plotting of Biopython records. This is really meant for use in a Jupyter/Ipython notebook with the \"%matplotlib inline\" setting. >>> from dna_features_viewer import BiopythonTranslator >>> BiopythonTranslator.quick_plot(my_record) \"\"\" graphic_record = self . translate_record ( record ) ax , _ = graphic_record . plot ( figure_width = figure_width , ** kwargs ) return ax","title":"quick_plot"},{"location":"reference/epijinn/Bedmethyl/#translate_feature_1","text":"def translate_feature ( self , feature ) Translate a Biopython feature into a Dna Features Viewer feature. View Source def translate_feature(self, feature): \"\"\"Translate a Biopython feature into a Dna Features Viewer feature.\"\"\" properties = dict( label=self.compute_feature_label(feature), color=self.compute_feature_color(feature), html=self.compute_feature_html(feature), fontdict=self.compute_feature_fontdict(feature), box_linewidth=self.compute_feature_box_linewidth(feature), box_color=self.compute_feature_box_color(feature), linewidth=self.compute_feature_linewidth(feature), label_link_color=self.compute_feature_label_link_color(feature), legend_text=self.compute_feature_legend_text(feature), ) if self.features_properties is not None: other_properties = self.features_properties if hasattr(other_properties, \"__call__\"): other_properties = other_properties(feature) properties.update(other_properties) return GraphicFeature( start=feature.location.start, end=feature.location.end, strand=feature.location.strand, **properties )","title":"translate_feature"},{"location":"reference/epijinn/Bedmethyl/#translate_record_1","text":"def translate_record ( self , record , record_class = None , filetype = None ) Create a new GraphicRecord from a BioPython Record object. Parameters: Name Type Description Default record None A BioPython Record object or the path to a Genbank or a GFF file. None record_class None The graphic record class to use, e.g. GraphicRecord (default) or CircularGraphicRecord. Strings 'circular' and 'linear' can also be provided. None filetype None Used only when a Genbank or a GFF file is provided; one of \"genbank\" or \"gff\" to be used. Default None infers from file extension. None View Source def translate_record ( self , record , record_class = None , filetype = None ) : \"\"\"Create a new GraphicRecord from a BioPython Record object. Parameters ---------- record A BioPython Record object or the path to a Genbank or a GFF file. record_class The graphic record class to use, e.g. GraphicRecord (default) or CircularGraphicRecord. Strings 'circular' and 'linear' can also be provided. filetype Used only when a Genbank or a GFF file is provided; one of \" genbank \" or \" gff \" to be used. Default None infers from file extension. \"\"\" classes = { \"linear\" : GraphicRecord , \"circular\" : CircularGraphicRecord , None : GraphicRecord , } if record_class in classes : record_class = classes [ record_class ] if isinstance ( record , str ) or hasattr ( record , \"read\" ) : record = load_record ( record , filetype = filetype ) filtered_features = self . compute_filtered_features ( record . features ) return record_class ( sequence_length = len ( record ), sequence = str ( record . seq ) if record . seq . defined else None , features =[ self.translate_feature(feature) for feature in filtered_features if feature.location is not None ] , ** self . graphic_record_parameters )","title":"translate_record"},{"location":"reference/epijinn/Methyl/","text":"Module epijinn.Methyl View Source # Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh # # This file is part of EpiJinn. # # EpiJinn is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. # # EpiJinn is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. # # You should have received a copy of the GNU General Public License along with Ediacara. If not, see <https://www.gnu.org/licenses/>. from Bio.Seq import Seq from Bio.SeqFeature import SeqFeature , FeatureLocation import dnachisel class Methylase : \"\"\"Methylase enzyme class. **Parameters** **name** > Name of the enzyme (`str`). **sequence** > Sequence of extended nucleotide characters (`str`). **index_pos** > Index of the methylated base on the positive strand (`int`). **index_neg** > Index of the methylated base on the negative strand (`int`). \"\"\" complement_table = { \"A\" : \"T\" , \"G\" : \"C\" , \"C\" : \"G\" , \"T\" : \"A\" , \"Y\" : \"R\" , \"R\" : \"Y\" , \"W\" : \"W\" , \"S\" : \"S\" , \"K\" : \"M\" , \"M\" : \"K\" , \"D\" : \"H\" , \"V\" : \"B\" , \"H\" : \"D\" , \"B\" : \"V\" , \"X\" : \"X\" , \"N\" : \"N\" , } def __init__ ( self , name , sequence , index_pos , index_neg ): self . name = name self . sequence = sequence self . rc = self . reverse_complement ( sequence ) self . index_pos = index_pos self . index_neg = index_neg @staticmethod def reverse ( sequence ): reverse = sequence [:: - 1 ] return reverse @staticmethod def complement ( sequence ): complement_letters = [ Methylase . complement_table [ letter ] for letter in sequence ] complement = \"\" . join ( complement_letters ) return complement @staticmethod def reverse_complement ( sequence ): r = Methylase . reverse ( sequence ) rc = Methylase . complement ( r ) return rc class Methylator : \"\"\"Class for finding methylation sites within a pattern (site) in a sequence. **Parameters** **sequence** > Sequence of ATGC characters (`str`). **site** > Sequence of restriction enzyme recognition site (`str`). **methylases** > Methylase class instances (`list`). Default uses built-in methylases. \"\"\" def __init__ ( self , sequence , site , methylases = None ): self . sequence = sequence if methylases is None : self . methylases = list ( METHYLASES . values ()) else : self . methylases = methylases self . site = site self . pattern = dnachisel . SequencePattern ( site ) self . regions_seq = self . pattern . find_matches ( self . sequence ) self . site_rc = Methylase . reverse_complement ( site ) self . pattern_rc = dnachisel . SequencePattern ( self . site_rc ) self . regions_rc = self . pattern_rc . find_matches ( self . sequence ) self . regions = self . regions_seq + self . regions_rc self . report = \"\" def find_methylation_sites_in_pattern ( self ): \"\"\"Run find_one_methylation_site_in_pattern() for each enzyme in methylases.\"\"\" self . report += \"Matches against methylase enzyme sites: \\n\\n \" for methylase in self . methylases : self . find_one_methylation_site_in_pattern ( methylase ) self . report += \" \\n \" def find_one_methylation_site_in_pattern ( self , methylase ): \"\"\"Find overlapping methylation and restriction sites.\"\"\" extended_regions = self . extend_restriction_regions ( methylase ) # For matching against positive strand of methylation pattern: expression = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . sequence ) pattern = dnachisel . SequencePattern ( expression ) # For matching against negative strand of methylation pattern: expression_rc = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . rc ) pattern_rc = dnachisel . SequencePattern ( expression_rc ) self . report += methylase . name + \" \\n \" self . report += \"=\" * len ( methylase . name ) + \" \\n \" for region in extended_regions : region_sequence = self . sequence [ region . start : region . end ] self . report += \"Region:\" + str ( region ) + \" \\n \" match_location = pattern . find_matches ( region_sequence ) if len ( match_location ) != 0 : self . report += \"Match in positive strand: %s \\n \" % region_sequence else : self . report += \"Positive strand: - \\n \" match_location_rc = pattern_rc . find_matches ( region_sequence ) if len ( match_location_rc ) != 0 : self . report += \"Match in negative strand: %s \\n \" % region_sequence else : self . report += \"Negative strand: - \\n \" self . report += \" \\n \" def extend_restriction_regions ( self , methylase ): \"\"\"Modify list of dnachisel.Location of restriction sites to include flanking nucleotides around restriction sites. \"\"\" extended_regions = [] for region in self . regions : region = region . extended ( methylase . index_neg , left = True , right = False ) # extension upstream m = len ( methylase . sequence ) - ( methylase . index_pos + 1 ) region = region . extended ( m , upper_limit = len ( self . sequence ), left = False , right = True ) # extension downstream extended_regions . append ( region ) return extended_regions def annotate_methylation ( seqrecord , methylases = None ): if methylases is None : methylases = list ( METHYLASES . values ()) for methylase in methylases : name = methylase . name regex = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . sequence ) pattern = dnachisel . SequencePattern ( regex ) match_location = pattern . find_matches ( str ( seqrecord . seq )) if len ( match_location ) != 0 : for match in match_location : label = \"@epijinn(\" + methylase . name + \")\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( match . start , match . end ), # dnachisel.Location type = \"misc_feature\" , id = \"@epijinn\" , qualifiers = { \"label\" : label , \"note\" : name }, ) ) # Mark the methylation site for checking overlap with restriction site methylated_position = match . start + methylase . index_pos methylated_nucleotide = str ( methylase . sequence [ methylase . index_pos ]) label = \"@epijinn(\" + methylated_nucleotide + \", strand=1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand = 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers = { \"label\" : label , \"note\" : name }, ) ) # Negative strand: methylated_position = match . start + methylase . index_neg methylated_nucleotide = str ( Seq ( methylase . sequence [ methylase . index_neg ]) . reverse_complement () ) label = \"@epijinn(\" + methylated_nucleotide + \", strand=-1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand =- 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers = { \"label\" : label , \"note\" : name }, ) ) # Repeat for reverse complement, if not palindromic: if Seq ( methylase . sequence ) != Seq ( methylase . sequence ) . reverse_complement (): name = methylase . name methylase_rc_seq = dnachisel . reverse_complement ( methylase . sequence ) regex = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase_rc_seq ) pattern = dnachisel . SequencePattern ( regex ) match_location = pattern . find_matches ( str ( seqrecord . seq )) if len ( match_location ) != 0 : for match in match_location : label = \"@epijinn_rc(\" + methylase . name + \")\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( match . start , match . end ), # dnachisel.Location type = \"misc_feature\" , id = \"@epijinn_rc\" , qualifiers = { \"label\" : label , \"note\" : name }, ) ) # Mark the methylation site: # reverse complement so need to count backwards, and strand=-1 # subtract 1 to account for range methylated_position = match . end - 1 - methylase . index_pos methylated_nucleotide = str ( methylase . sequence [ methylase . index_pos ]) label = \"@epijinn(\" + methylated_nucleotide + \", strand=-1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand =- 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers = { \"label\" : label , \"note\" : name }, ) ) # Mark methylation in antisense of the enzyme site: # reverse complement so need to count backwards, and strand=1 # subtract 1 to account for range methylated_position = match . end - 1 - methylase . index_neg methylated_nucleotide = str ( Seq ( methylase . sequence [ methylase . index_neg ] ) . reverse_complement () ) label = \"@epijinn(\" + methylated_nucleotide + \", strand=1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand = 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers = { \"label\" : label , \"note\" : name }, ) ) return seqrecord # Cytosine: AluI = Methylase ( name = \"AluI\" , sequence = \"AGCT\" , index_pos = 2 , index_neg = 1 ) BamHI = Methylase ( name = \"BamHI\" , sequence = \"GGATCC\" , index_pos = 4 , index_neg = 1 ) CpG = Methylase ( name = \"CpG\" , sequence = \"CG\" , index_pos = 0 , index_neg = 1 ) EcoKDcm = Methylase ( name = \"EcoKDcm\" , sequence = \"CCWGG\" , index_pos = 1 , index_neg = 3 ) GpC = Methylase ( name = \"GpC\" , sequence = \"GC\" , index_pos = 1 , index_neg = 0 ) HaeIII = Methylase ( name = \"HaeIII\" , sequence = \"GGCC\" , index_pos = 2 , index_neg = 1 ) Hhal = Methylase ( name = \"Hhal\" , sequence = \"GCGC\" , index_pos = 1 , index_neg = 2 ) HpaII = Methylase ( name = \"HpaII\" , sequence = \"CCGG\" , index_pos = 1 , index_neg = 2 ) MspI = Methylase ( name = \"MspI\" , sequence = \"CCGG\" , index_pos = 0 , index_neg = 3 ) # Adenine: EcoBI = Methylase ( name = \"EcoBI\" , sequence = \"TGANNNNNNNNTGCT\" , index_pos = 2 , index_neg = 11 ) # EcoGII = Methylase(name=\"EcoGII\", sequence=\"A\", index_pos=0, index_neg=) # no valid index_neg value EcoKDam = Methylase ( name = \"EcoKDam\" , sequence = \"GATC\" , index_pos = 1 , index_neg = 2 ) EcoKI = Methylase ( name = \"EcoKI\" , sequence = \"AACNNNNNNGTGC\" , index_pos = 1 , index_neg = 10 ) EcoRI = Methylase ( name = \"EcoRI\" , sequence = \"GAATTC\" , index_pos = 2 , index_neg = 3 ) TaqI = Methylase ( name = \"TaqI\" , sequence = \"TCGA\" , index_pos = 3 , index_neg = 0 ) METHYLASES = { AluI . name : AluI , BamHI . name : BamHI , CpG . name : CpG , EcoKDcm . name : EcoKDcm , GpC . name : GpC , HaeIII . name : HaeIII , Hhal . name : Hhal , HpaII . name : HpaII , MspI . name : MspI , EcoBI . name : EcoBI , # EcoGII.name: EcoGII, EcoKDam . name : EcoKDam , EcoKI . name : EcoKI , EcoRI . name : EcoRI , TaqI . name : TaqI , } Variables AluI BamHI CpG EcoBI EcoKDam EcoKDcm EcoKI EcoRI GpC HaeIII Hhal HpaII METHYLASES MspI TaqI Functions annotate_methylation def annotate_methylation ( seqrecord , methylases = None ) View Source def annotate_methylation ( seqrecord , methylases = None ): if methylases is None : methylases = list ( METHYLASES . values ()) for methylase in methylases : name = methylase . name regex = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . sequence ) pattern = dnachisel . SequencePattern ( regex ) match_location = pattern . find_matches ( str ( seqrecord . seq )) if len ( match_location ) != 0 : for match in match_location : label = \"@epijinn(\" + methylase . name + \")\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( match . start , match . end ), # dnachisel . Location type = \"misc_feature\" , id = \"@epijinn\" , qualifiers ={ \"label\" : label , \"note\" : name }, ) ) # Mark the methylation site for checking overlap with restriction site methylated_position = match . start + methylase . index_pos methylated_nucleotide = str ( methylase . sequence [ methylase . index_pos ]) label = \"@epijinn(\" + methylated_nucleotide + \", strand=1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand = 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers ={ \"label\" : label , \"note\" : name }, ) ) # Negative strand : methylated_position = match . start + methylase . index_neg methylated_nucleotide = str ( Seq ( methylase . sequence [ methylase . index_neg ]). reverse_complement () ) label = \"@epijinn(\" + methylated_nucleotide + \", strand=-1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand = - 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers ={ \"label\" : label , \"note\" : name }, ) ) # Repeat for reverse complement , if not palindromic : if Seq ( methylase . sequence ) != Seq ( methylase . sequence ). reverse_complement (): name = methylase . name methylase_rc_seq = dnachisel . reverse_complement ( methylase . sequence ) regex = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase_rc_seq ) pattern = dnachisel . SequencePattern ( regex ) match_location = pattern . find_matches ( str ( seqrecord . seq )) if len ( match_location ) != 0 : for match in match_location : label = \"@epijinn_rc(\" + methylase . name + \")\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( match . start , match . end ), # dnachisel . Location type = \"misc_feature\" , id = \"@epijinn_rc\" , qualifiers ={ \"label\" : label , \"note\" : name }, ) ) # Mark the methylation site : # reverse complement so need to count backwards , and strand = - 1 # subtract 1 to account for range methylated_position = match . end - 1 - methylase . index_pos methylated_nucleotide = str ( methylase . sequence [ methylase . index_pos ]) label = \"@epijinn(\" + methylated_nucleotide + \", strand=-1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand = - 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers ={ \"label\" : label , \"note\" : name }, ) ) # Mark methylation in antisense of the enzyme site : # reverse complement so need to count backwards , and strand = 1 # subtract 1 to account for range methylated_position = match . end - 1 - methylase . index_neg methylated_nucleotide = str ( Seq ( methylase . sequence [ methylase . index_neg ] ). reverse_complement () ) label = \"@epijinn(\" + methylated_nucleotide + \", strand=1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand = 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers ={ \"label\" : label , \"note\" : name }, ) ) return seqrecord Classes Methylase class Methylase ( name , sequence , index_pos , index_neg ) Methylase enzyme class. Parameters name Name of the enzyme ( str ). sequence Sequence of extended nucleotide characters ( str ). index_pos Index of the methylated base on the positive strand ( int ). index_neg Index of the methylated base on the negative strand ( int ). View Source class Methylase : \"\"\"Methylase enzyme class. **Parameters** **name** > Name of the enzyme (`str`). **sequence** > Sequence of extended nucleotide characters (`str`). **index_pos** > Index of the methylated base on the positive strand (`int`). **index_neg** > Index of the methylated base on the negative strand (`int`). \"\"\" complement_table = { \"A\" : \"T\" , \"G\" : \"C\" , \"C\" : \"G\" , \"T\" : \"A\" , \"Y\" : \"R\" , \"R\" : \"Y\" , \"W\" : \"W\" , \"S\" : \"S\" , \"K\" : \"M\" , \"M\" : \"K\" , \"D\" : \"H\" , \"V\" : \"B\" , \"H\" : \"D\" , \"B\" : \"V\" , \"X\" : \"X\" , \"N\" : \"N\" , } def __ init__ ( self , name , sequence , index_pos , index_neg ) : self . name = name self . sequence = sequence self . rc = self . reverse_complement ( sequence ) self . index_pos = index_pos self . index_neg = index_neg @staticmethod def reverse ( sequence ) : reverse = sequence [ ::- 1 ] return reverse @staticmethod def complement ( sequence ) : complement_letters = [ Methylase . complement_table [ letter ] for letter in sequence ] complement = \"\" . join ( complement_letters ) return complement @staticmethod def reverse_complement ( sequence ) : r = Methylase . reverse ( sequence ) rc = Methylase . complement ( r ) return rc Descendants epijinn.dnd.Dnd Class variables complement_table Static methods complement def complement ( sequence ) View Source @staticmethod def complement ( sequence ) : complement_letters = [ Methylase.complement_table[letter ] for letter in sequence ] complement = \"\" . join ( complement_letters ) return complement reverse def reverse ( sequence ) View Source @staticmethod def reverse ( sequence ) : reverse = sequence [ ::- 1 ] return reverse reverse_complement def reverse_complement ( sequence ) View Source @staticmethod def reverse_complement ( sequence ) : r = Methylase . reverse ( sequence ) rc = Methylase . complement ( r ) return rc Methylator class Methylator ( sequence , site , methylases = None ) Class for finding methylation sites within a pattern (site) in a sequence. Parameters sequence Sequence of ATGC characters ( str ). site Sequence of restriction enzyme recognition site ( str ). methylases Methylase class instances ( list ). Default uses built-in methylases. View Source class Methylator : \" \"\" Class for finding methylation sites within a pattern (site) in a sequence. **Parameters** **sequence** > Sequence of ATGC characters (`str`). **site** > Sequence of restriction enzyme recognition site (`str`). **methylases** > Methylase class instances (`list`). Default uses built-in methylases. \"\" \" def __init__ ( self , sequence , site , methylases = None ) : self . sequence = sequence if methylases is None : self . methylases = list ( METHYLASES . values ()) else : self . methylases = methylases self . site = site self . pattern = dnachisel . SequencePattern ( site ) self . regions_seq = self . pattern . find_matches ( self . sequence ) self . site_rc = Methylase . reverse_complement ( site ) self . pattern_rc = dnachisel . SequencePattern ( self . site_rc ) self . regions_rc = self . pattern_rc . find_matches ( self . sequence ) self . regions = self . regions_seq + self . regions_rc self . report = \"\" def find_methylation_sites_in_pattern ( self ) : \" \"\" Run find_one_methylation_site_in_pattern() for each enzyme in methylases. \"\" \" self . report += \"Matches against methylase enzyme sites: \\n\\n \" for methylase in self . methylases : self . find_one_methylation_site_in_pattern ( methylase ) self . report += \" \\n \" def find_one_methylation_site_in_pattern ( self , methylase ) : \" \"\" Find overlapping methylation and restriction sites. \"\" \" extended_regions = self . extend_restriction_regions ( methylase ) # For matching against positive strand of methylation pattern: expression = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . sequence ) pattern = dnachisel . SequencePattern ( expression ) # For matching against negative strand of methylation pattern: expression_rc = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . rc ) pattern_rc = dnachisel . SequencePattern ( expression_rc ) self . report += methylase . name + \" \\n \" self . report += \"=\" * len ( methylase . name ) + \" \\n \" for region in extended_regions : region_sequence = self . sequence [ region . start : region . end ] self . report += \"Region:\" + str ( region ) + \" \\n \" match_location = pattern . find_matches ( region_sequence ) if len ( match_location ) != 0 : self . report += \"Match in positive strand: %s \\n \" % region_sequence else : self . report += \"Positive strand: - \\n \" match_location_rc = pattern_rc . find_matches ( region_sequence ) if len ( match_location_rc ) != 0 : self . report += \"Match in negative strand: %s \\n \" % region_sequence else : self . report += \"Negative strand: - \\n \" self . report += \" \\n \" def extend_restriction_regions ( self , methylase ) : \" \"\" Modify list of dnachisel.Location of restriction sites to include flanking nucleotides around restriction sites. \"\" \" extended_regions = [] for region in self . regions : region = region . extended ( methylase . index_neg , left = True , right = False ) # extension upstream m = len ( methylase . sequence ) - ( methylase . index_pos + 1 ) region = region . extended ( m , upper_limit = len ( self . sequence ), left = False , right = True ) # extension downstream extended_regions . append ( region ) return extended_regions Methods extend_restriction_regions def extend_restriction_regions ( self , methylase ) Modify list of dnachisel.Location of restriction sites to include flanking nucleotides around restriction sites. View Source def extend_restriction_regions ( self , methylase ) : \"\"\"Modify list of dnachisel.Location of restriction sites to include flanking nucleotides around restriction sites . \"\"\" extended_regions = [] for region in self . regions: region = region . extended ( methylase . index_neg , left = True , right = False ) # extension upstream m = len ( methylase . sequence ) - ( methylase . index_pos + 1 ) region = region . extended ( m , upper_limit = len ( self . sequence ), left = False , right = True ) # extension downstream extended_regions . append ( region ) return extended_regions find_methylation_sites_in_pattern def find_methylation_sites_in_pattern ( self ) Run find_one_methylation_site_in_pattern() for each enzyme in methylases. View Source def find_methylation_sites_in_pattern(self): \"\"\"Run find_one_methylation_site_in_pattern() for each enzyme in methylases.\"\"\" self.report += \"Matches against methylase enzyme sites:\\n\\n\" for methylase in self.methylases: self.find_one_methylation_site_in_pattern(methylase) self.report += \"\\n\" find_one_methylation_site_in_pattern def find_one_methylation_site_in_pattern ( self , methylase ) Find overlapping methylation and restriction sites. View Source def find_one_methylation_site_in_pattern ( self , methylase ) : \"\"\"Find overlapping methylation and restriction sites.\"\"\" extended_regions = self . extend_restriction_regions ( methylase ) # For matching against positive strand of methylation pattern: expression = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . sequence ) pattern = dnachisel . SequencePattern ( expression ) # For matching against negative strand of methylation pattern: expression_rc = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . rc ) pattern_rc = dnachisel . SequencePattern ( expression_rc ) self . report += methylase . name + \" \\n \" self . report += \"=\" * len ( methylase . name ) + \" \\n \" for region in extended_regions: region_sequence = self . sequence [ region . start : region . end ] self . report += \"Region:\" + str ( region ) + \" \\n \" match_location = pattern . find_matches ( region_sequence ) if len ( match_location ) != 0 : self . report += \"Match in positive strand: %s \\n \" % region_sequence else : self . report += \"Positive strand: - \\n \" match_location_rc = pattern_rc . find_matches ( region_sequence ) if len ( match_location_rc ) != 0 : self . report += \"Match in negative strand: %s \\n \" % region_sequence else : self . report += \"Negative strand: - \\n \" self . report += \" \\n \"","title":"Methyl"},{"location":"reference/epijinn/Methyl/#module-epijinnmethyl","text":"View Source # Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh # # This file is part of EpiJinn. # # EpiJinn is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. # # EpiJinn is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. # # You should have received a copy of the GNU General Public License along with Ediacara. If not, see <https://www.gnu.org/licenses/>. from Bio.Seq import Seq from Bio.SeqFeature import SeqFeature , FeatureLocation import dnachisel class Methylase : \"\"\"Methylase enzyme class. **Parameters** **name** > Name of the enzyme (`str`). **sequence** > Sequence of extended nucleotide characters (`str`). **index_pos** > Index of the methylated base on the positive strand (`int`). **index_neg** > Index of the methylated base on the negative strand (`int`). \"\"\" complement_table = { \"A\" : \"T\" , \"G\" : \"C\" , \"C\" : \"G\" , \"T\" : \"A\" , \"Y\" : \"R\" , \"R\" : \"Y\" , \"W\" : \"W\" , \"S\" : \"S\" , \"K\" : \"M\" , \"M\" : \"K\" , \"D\" : \"H\" , \"V\" : \"B\" , \"H\" : \"D\" , \"B\" : \"V\" , \"X\" : \"X\" , \"N\" : \"N\" , } def __init__ ( self , name , sequence , index_pos , index_neg ): self . name = name self . sequence = sequence self . rc = self . reverse_complement ( sequence ) self . index_pos = index_pos self . index_neg = index_neg @staticmethod def reverse ( sequence ): reverse = sequence [:: - 1 ] return reverse @staticmethod def complement ( sequence ): complement_letters = [ Methylase . complement_table [ letter ] for letter in sequence ] complement = \"\" . join ( complement_letters ) return complement @staticmethod def reverse_complement ( sequence ): r = Methylase . reverse ( sequence ) rc = Methylase . complement ( r ) return rc class Methylator : \"\"\"Class for finding methylation sites within a pattern (site) in a sequence. **Parameters** **sequence** > Sequence of ATGC characters (`str`). **site** > Sequence of restriction enzyme recognition site (`str`). **methylases** > Methylase class instances (`list`). Default uses built-in methylases. \"\"\" def __init__ ( self , sequence , site , methylases = None ): self . sequence = sequence if methylases is None : self . methylases = list ( METHYLASES . values ()) else : self . methylases = methylases self . site = site self . pattern = dnachisel . SequencePattern ( site ) self . regions_seq = self . pattern . find_matches ( self . sequence ) self . site_rc = Methylase . reverse_complement ( site ) self . pattern_rc = dnachisel . SequencePattern ( self . site_rc ) self . regions_rc = self . pattern_rc . find_matches ( self . sequence ) self . regions = self . regions_seq + self . regions_rc self . report = \"\" def find_methylation_sites_in_pattern ( self ): \"\"\"Run find_one_methylation_site_in_pattern() for each enzyme in methylases.\"\"\" self . report += \"Matches against methylase enzyme sites: \\n\\n \" for methylase in self . methylases : self . find_one_methylation_site_in_pattern ( methylase ) self . report += \" \\n \" def find_one_methylation_site_in_pattern ( self , methylase ): \"\"\"Find overlapping methylation and restriction sites.\"\"\" extended_regions = self . extend_restriction_regions ( methylase ) # For matching against positive strand of methylation pattern: expression = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . sequence ) pattern = dnachisel . SequencePattern ( expression ) # For matching against negative strand of methylation pattern: expression_rc = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . rc ) pattern_rc = dnachisel . SequencePattern ( expression_rc ) self . report += methylase . name + \" \\n \" self . report += \"=\" * len ( methylase . name ) + \" \\n \" for region in extended_regions : region_sequence = self . sequence [ region . start : region . end ] self . report += \"Region:\" + str ( region ) + \" \\n \" match_location = pattern . find_matches ( region_sequence ) if len ( match_location ) != 0 : self . report += \"Match in positive strand: %s \\n \" % region_sequence else : self . report += \"Positive strand: - \\n \" match_location_rc = pattern_rc . find_matches ( region_sequence ) if len ( match_location_rc ) != 0 : self . report += \"Match in negative strand: %s \\n \" % region_sequence else : self . report += \"Negative strand: - \\n \" self . report += \" \\n \" def extend_restriction_regions ( self , methylase ): \"\"\"Modify list of dnachisel.Location of restriction sites to include flanking nucleotides around restriction sites. \"\"\" extended_regions = [] for region in self . regions : region = region . extended ( methylase . index_neg , left = True , right = False ) # extension upstream m = len ( methylase . sequence ) - ( methylase . index_pos + 1 ) region = region . extended ( m , upper_limit = len ( self . sequence ), left = False , right = True ) # extension downstream extended_regions . append ( region ) return extended_regions def annotate_methylation ( seqrecord , methylases = None ): if methylases is None : methylases = list ( METHYLASES . values ()) for methylase in methylases : name = methylase . name regex = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . sequence ) pattern = dnachisel . SequencePattern ( regex ) match_location = pattern . find_matches ( str ( seqrecord . seq )) if len ( match_location ) != 0 : for match in match_location : label = \"@epijinn(\" + methylase . name + \")\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( match . start , match . end ), # dnachisel.Location type = \"misc_feature\" , id = \"@epijinn\" , qualifiers = { \"label\" : label , \"note\" : name }, ) ) # Mark the methylation site for checking overlap with restriction site methylated_position = match . start + methylase . index_pos methylated_nucleotide = str ( methylase . sequence [ methylase . index_pos ]) label = \"@epijinn(\" + methylated_nucleotide + \", strand=1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand = 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers = { \"label\" : label , \"note\" : name }, ) ) # Negative strand: methylated_position = match . start + methylase . index_neg methylated_nucleotide = str ( Seq ( methylase . sequence [ methylase . index_neg ]) . reverse_complement () ) label = \"@epijinn(\" + methylated_nucleotide + \", strand=-1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand =- 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers = { \"label\" : label , \"note\" : name }, ) ) # Repeat for reverse complement, if not palindromic: if Seq ( methylase . sequence ) != Seq ( methylase . sequence ) . reverse_complement (): name = methylase . name methylase_rc_seq = dnachisel . reverse_complement ( methylase . sequence ) regex = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase_rc_seq ) pattern = dnachisel . SequencePattern ( regex ) match_location = pattern . find_matches ( str ( seqrecord . seq )) if len ( match_location ) != 0 : for match in match_location : label = \"@epijinn_rc(\" + methylase . name + \")\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( match . start , match . end ), # dnachisel.Location type = \"misc_feature\" , id = \"@epijinn_rc\" , qualifiers = { \"label\" : label , \"note\" : name }, ) ) # Mark the methylation site: # reverse complement so need to count backwards, and strand=-1 # subtract 1 to account for range methylated_position = match . end - 1 - methylase . index_pos methylated_nucleotide = str ( methylase . sequence [ methylase . index_pos ]) label = \"@epijinn(\" + methylated_nucleotide + \", strand=-1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand =- 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers = { \"label\" : label , \"note\" : name }, ) ) # Mark methylation in antisense of the enzyme site: # reverse complement so need to count backwards, and strand=1 # subtract 1 to account for range methylated_position = match . end - 1 - methylase . index_neg methylated_nucleotide = str ( Seq ( methylase . sequence [ methylase . index_neg ] ) . reverse_complement () ) label = \"@epijinn(\" + methylated_nucleotide + \", strand=1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand = 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers = { \"label\" : label , \"note\" : name }, ) ) return seqrecord # Cytosine: AluI = Methylase ( name = \"AluI\" , sequence = \"AGCT\" , index_pos = 2 , index_neg = 1 ) BamHI = Methylase ( name = \"BamHI\" , sequence = \"GGATCC\" , index_pos = 4 , index_neg = 1 ) CpG = Methylase ( name = \"CpG\" , sequence = \"CG\" , index_pos = 0 , index_neg = 1 ) EcoKDcm = Methylase ( name = \"EcoKDcm\" , sequence = \"CCWGG\" , index_pos = 1 , index_neg = 3 ) GpC = Methylase ( name = \"GpC\" , sequence = \"GC\" , index_pos = 1 , index_neg = 0 ) HaeIII = Methylase ( name = \"HaeIII\" , sequence = \"GGCC\" , index_pos = 2 , index_neg = 1 ) Hhal = Methylase ( name = \"Hhal\" , sequence = \"GCGC\" , index_pos = 1 , index_neg = 2 ) HpaII = Methylase ( name = \"HpaII\" , sequence = \"CCGG\" , index_pos = 1 , index_neg = 2 ) MspI = Methylase ( name = \"MspI\" , sequence = \"CCGG\" , index_pos = 0 , index_neg = 3 ) # Adenine: EcoBI = Methylase ( name = \"EcoBI\" , sequence = \"TGANNNNNNNNTGCT\" , index_pos = 2 , index_neg = 11 ) # EcoGII = Methylase(name=\"EcoGII\", sequence=\"A\", index_pos=0, index_neg=) # no valid index_neg value EcoKDam = Methylase ( name = \"EcoKDam\" , sequence = \"GATC\" , index_pos = 1 , index_neg = 2 ) EcoKI = Methylase ( name = \"EcoKI\" , sequence = \"AACNNNNNNGTGC\" , index_pos = 1 , index_neg = 10 ) EcoRI = Methylase ( name = \"EcoRI\" , sequence = \"GAATTC\" , index_pos = 2 , index_neg = 3 ) TaqI = Methylase ( name = \"TaqI\" , sequence = \"TCGA\" , index_pos = 3 , index_neg = 0 ) METHYLASES = { AluI . name : AluI , BamHI . name : BamHI , CpG . name : CpG , EcoKDcm . name : EcoKDcm , GpC . name : GpC , HaeIII . name : HaeIII , Hhal . name : Hhal , HpaII . name : HpaII , MspI . name : MspI , EcoBI . name : EcoBI , # EcoGII.name: EcoGII, EcoKDam . name : EcoKDam , EcoKI . name : EcoKI , EcoRI . name : EcoRI , TaqI . name : TaqI , }","title":"Module epijinn.Methyl"},{"location":"reference/epijinn/Methyl/#variables","text":"AluI BamHI CpG EcoBI EcoKDam EcoKDcm EcoKI EcoRI GpC HaeIII Hhal HpaII METHYLASES MspI TaqI","title":"Variables"},{"location":"reference/epijinn/Methyl/#functions","text":"","title":"Functions"},{"location":"reference/epijinn/Methyl/#annotate_methylation","text":"def annotate_methylation ( seqrecord , methylases = None ) View Source def annotate_methylation ( seqrecord , methylases = None ): if methylases is None : methylases = list ( METHYLASES . values ()) for methylase in methylases : name = methylase . name regex = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . sequence ) pattern = dnachisel . SequencePattern ( regex ) match_location = pattern . find_matches ( str ( seqrecord . seq )) if len ( match_location ) != 0 : for match in match_location : label = \"@epijinn(\" + methylase . name + \")\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( match . start , match . end ), # dnachisel . Location type = \"misc_feature\" , id = \"@epijinn\" , qualifiers ={ \"label\" : label , \"note\" : name }, ) ) # Mark the methylation site for checking overlap with restriction site methylated_position = match . start + methylase . index_pos methylated_nucleotide = str ( methylase . sequence [ methylase . index_pos ]) label = \"@epijinn(\" + methylated_nucleotide + \", strand=1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand = 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers ={ \"label\" : label , \"note\" : name }, ) ) # Negative strand : methylated_position = match . start + methylase . index_neg methylated_nucleotide = str ( Seq ( methylase . sequence [ methylase . index_neg ]). reverse_complement () ) label = \"@epijinn(\" + methylated_nucleotide + \", strand=-1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand = - 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers ={ \"label\" : label , \"note\" : name }, ) ) # Repeat for reverse complement , if not palindromic : if Seq ( methylase . sequence ) != Seq ( methylase . sequence ). reverse_complement (): name = methylase . name methylase_rc_seq = dnachisel . reverse_complement ( methylase . sequence ) regex = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase_rc_seq ) pattern = dnachisel . SequencePattern ( regex ) match_location = pattern . find_matches ( str ( seqrecord . seq )) if len ( match_location ) != 0 : for match in match_location : label = \"@epijinn_rc(\" + methylase . name + \")\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( match . start , match . end ), # dnachisel . Location type = \"misc_feature\" , id = \"@epijinn_rc\" , qualifiers ={ \"label\" : label , \"note\" : name }, ) ) # Mark the methylation site : # reverse complement so need to count backwards , and strand = - 1 # subtract 1 to account for range methylated_position = match . end - 1 - methylase . index_pos methylated_nucleotide = str ( methylase . sequence [ methylase . index_pos ]) label = \"@epijinn(\" + methylated_nucleotide + \", strand=-1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand = - 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers ={ \"label\" : label , \"note\" : name }, ) ) # Mark methylation in antisense of the enzyme site : # reverse complement so need to count backwards , and strand = 1 # subtract 1 to account for range methylated_position = match . end - 1 - methylase . index_neg methylated_nucleotide = str ( Seq ( methylase . sequence [ methylase . index_neg ] ). reverse_complement () ) label = \"@epijinn(\" + methylated_nucleotide + \", strand=1)\" seqrecord . features . append ( SeqFeature ( FeatureLocation ( methylated_position , methylated_position + 1 , strand = 1 ), type = \"misc_feature\" , id = \"@epijinn\" , qualifiers ={ \"label\" : label , \"note\" : name }, ) ) return seqrecord","title":"annotate_methylation"},{"location":"reference/epijinn/Methyl/#classes","text":"","title":"Classes"},{"location":"reference/epijinn/Methyl/#methylase","text":"class Methylase ( name , sequence , index_pos , index_neg ) Methylase enzyme class. Parameters name Name of the enzyme ( str ). sequence Sequence of extended nucleotide characters ( str ). index_pos Index of the methylated base on the positive strand ( int ). index_neg Index of the methylated base on the negative strand ( int ). View Source class Methylase : \"\"\"Methylase enzyme class. **Parameters** **name** > Name of the enzyme (`str`). **sequence** > Sequence of extended nucleotide characters (`str`). **index_pos** > Index of the methylated base on the positive strand (`int`). **index_neg** > Index of the methylated base on the negative strand (`int`). \"\"\" complement_table = { \"A\" : \"T\" , \"G\" : \"C\" , \"C\" : \"G\" , \"T\" : \"A\" , \"Y\" : \"R\" , \"R\" : \"Y\" , \"W\" : \"W\" , \"S\" : \"S\" , \"K\" : \"M\" , \"M\" : \"K\" , \"D\" : \"H\" , \"V\" : \"B\" , \"H\" : \"D\" , \"B\" : \"V\" , \"X\" : \"X\" , \"N\" : \"N\" , } def __ init__ ( self , name , sequence , index_pos , index_neg ) : self . name = name self . sequence = sequence self . rc = self . reverse_complement ( sequence ) self . index_pos = index_pos self . index_neg = index_neg @staticmethod def reverse ( sequence ) : reverse = sequence [ ::- 1 ] return reverse @staticmethod def complement ( sequence ) : complement_letters = [ Methylase . complement_table [ letter ] for letter in sequence ] complement = \"\" . join ( complement_letters ) return complement @staticmethod def reverse_complement ( sequence ) : r = Methylase . reverse ( sequence ) rc = Methylase . complement ( r ) return rc","title":"Methylase"},{"location":"reference/epijinn/Methyl/#descendants","text":"epijinn.dnd.Dnd","title":"Descendants"},{"location":"reference/epijinn/Methyl/#class-variables","text":"complement_table","title":"Class variables"},{"location":"reference/epijinn/Methyl/#static-methods","text":"","title":"Static methods"},{"location":"reference/epijinn/Methyl/#complement","text":"def complement ( sequence ) View Source @staticmethod def complement ( sequence ) : complement_letters = [ Methylase.complement_table[letter ] for letter in sequence ] complement = \"\" . join ( complement_letters ) return complement","title":"complement"},{"location":"reference/epijinn/Methyl/#reverse","text":"def reverse ( sequence ) View Source @staticmethod def reverse ( sequence ) : reverse = sequence [ ::- 1 ] return reverse","title":"reverse"},{"location":"reference/epijinn/Methyl/#reverse_complement","text":"def reverse_complement ( sequence ) View Source @staticmethod def reverse_complement ( sequence ) : r = Methylase . reverse ( sequence ) rc = Methylase . complement ( r ) return rc","title":"reverse_complement"},{"location":"reference/epijinn/Methyl/#methylator","text":"class Methylator ( sequence , site , methylases = None ) Class for finding methylation sites within a pattern (site) in a sequence. Parameters sequence Sequence of ATGC characters ( str ). site Sequence of restriction enzyme recognition site ( str ). methylases Methylase class instances ( list ). Default uses built-in methylases. View Source class Methylator : \" \"\" Class for finding methylation sites within a pattern (site) in a sequence. **Parameters** **sequence** > Sequence of ATGC characters (`str`). **site** > Sequence of restriction enzyme recognition site (`str`). **methylases** > Methylase class instances (`list`). Default uses built-in methylases. \"\" \" def __init__ ( self , sequence , site , methylases = None ) : self . sequence = sequence if methylases is None : self . methylases = list ( METHYLASES . values ()) else : self . methylases = methylases self . site = site self . pattern = dnachisel . SequencePattern ( site ) self . regions_seq = self . pattern . find_matches ( self . sequence ) self . site_rc = Methylase . reverse_complement ( site ) self . pattern_rc = dnachisel . SequencePattern ( self . site_rc ) self . regions_rc = self . pattern_rc . find_matches ( self . sequence ) self . regions = self . regions_seq + self . regions_rc self . report = \"\" def find_methylation_sites_in_pattern ( self ) : \" \"\" Run find_one_methylation_site_in_pattern() for each enzyme in methylases. \"\" \" self . report += \"Matches against methylase enzyme sites: \\n\\n \" for methylase in self . methylases : self . find_one_methylation_site_in_pattern ( methylase ) self . report += \" \\n \" def find_one_methylation_site_in_pattern ( self , methylase ) : \" \"\" Find overlapping methylation and restriction sites. \"\" \" extended_regions = self . extend_restriction_regions ( methylase ) # For matching against positive strand of methylation pattern: expression = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . sequence ) pattern = dnachisel . SequencePattern ( expression ) # For matching against negative strand of methylation pattern: expression_rc = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . rc ) pattern_rc = dnachisel . SequencePattern ( expression_rc ) self . report += methylase . name + \" \\n \" self . report += \"=\" * len ( methylase . name ) + \" \\n \" for region in extended_regions : region_sequence = self . sequence [ region . start : region . end ] self . report += \"Region:\" + str ( region ) + \" \\n \" match_location = pattern . find_matches ( region_sequence ) if len ( match_location ) != 0 : self . report += \"Match in positive strand: %s \\n \" % region_sequence else : self . report += \"Positive strand: - \\n \" match_location_rc = pattern_rc . find_matches ( region_sequence ) if len ( match_location_rc ) != 0 : self . report += \"Match in negative strand: %s \\n \" % region_sequence else : self . report += \"Negative strand: - \\n \" self . report += \" \\n \" def extend_restriction_regions ( self , methylase ) : \" \"\" Modify list of dnachisel.Location of restriction sites to include flanking nucleotides around restriction sites. \"\" \" extended_regions = [] for region in self . regions : region = region . extended ( methylase . index_neg , left = True , right = False ) # extension upstream m = len ( methylase . sequence ) - ( methylase . index_pos + 1 ) region = region . extended ( m , upper_limit = len ( self . sequence ), left = False , right = True ) # extension downstream extended_regions . append ( region ) return extended_regions","title":"Methylator"},{"location":"reference/epijinn/Methyl/#methods","text":"","title":"Methods"},{"location":"reference/epijinn/Methyl/#extend_restriction_regions","text":"def extend_restriction_regions ( self , methylase ) Modify list of dnachisel.Location of restriction sites to include flanking nucleotides around restriction sites. View Source def extend_restriction_regions ( self , methylase ) : \"\"\"Modify list of dnachisel.Location of restriction sites to include flanking nucleotides around restriction sites . \"\"\" extended_regions = [] for region in self . regions: region = region . extended ( methylase . index_neg , left = True , right = False ) # extension upstream m = len ( methylase . sequence ) - ( methylase . index_pos + 1 ) region = region . extended ( m , upper_limit = len ( self . sequence ), left = False , right = True ) # extension downstream extended_regions . append ( region ) return extended_regions","title":"extend_restriction_regions"},{"location":"reference/epijinn/Methyl/#find_methylation_sites_in_pattern","text":"def find_methylation_sites_in_pattern ( self ) Run find_one_methylation_site_in_pattern() for each enzyme in methylases. View Source def find_methylation_sites_in_pattern(self): \"\"\"Run find_one_methylation_site_in_pattern() for each enzyme in methylases.\"\"\" self.report += \"Matches against methylase enzyme sites:\\n\\n\" for methylase in self.methylases: self.find_one_methylation_site_in_pattern(methylase) self.report += \"\\n\"","title":"find_methylation_sites_in_pattern"},{"location":"reference/epijinn/Methyl/#find_one_methylation_site_in_pattern","text":"def find_one_methylation_site_in_pattern ( self , methylase ) Find overlapping methylation and restriction sites. View Source def find_one_methylation_site_in_pattern ( self , methylase ) : \"\"\"Find overlapping methylation and restriction sites.\"\"\" extended_regions = self . extend_restriction_regions ( methylase ) # For matching against positive strand of methylation pattern: expression = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . sequence ) pattern = dnachisel . SequencePattern ( expression ) # For matching against negative strand of methylation pattern: expression_rc = dnachisel . DnaNotationPattern . dna_sequence_to_regexpr ( methylase . rc ) pattern_rc = dnachisel . SequencePattern ( expression_rc ) self . report += methylase . name + \" \\n \" self . report += \"=\" * len ( methylase . name ) + \" \\n \" for region in extended_regions: region_sequence = self . sequence [ region . start : region . end ] self . report += \"Region:\" + str ( region ) + \" \\n \" match_location = pattern . find_matches ( region_sequence ) if len ( match_location ) != 0 : self . report += \"Match in positive strand: %s \\n \" % region_sequence else : self . report += \"Positive strand: - \\n \" match_location_rc = pattern_rc . find_matches ( region_sequence ) if len ( match_location_rc ) != 0 : self . report += \"Match in negative strand: %s \\n \" % region_sequence else : self . report += \"Negative strand: - \\n \" self . report += \" \\n \"","title":"find_one_methylation_site_in_pattern"},{"location":"reference/epijinn/dnd/","text":"Module epijinn.dnd View Source # Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh # # This file is part of EpiJinn. # # EpiJinn is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. # # EpiJinn is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. # # You should have received a copy of the GNU General Public License along with Ediacara. If not, see <https://www.gnu.org/licenses/>. from .Methyl import Methylase class Dnd ( Methylase ): pass Dnd_EcoB7A = Dnd ( \"Dnd_EcoB7A\" , \"GAAC\" , 0 , 3 ) Dnd_Sli1326 = Dnd ( \"Dnd_Sli1326\" , \"GGCC\" , 0 , 3 ) Dnd_VciFF75 = Dnd ( \"Dnd_VciFF75\" , \"CCA\" , 0 , 2 ) DND = [ Dnd_EcoB7A , Dnd_Sli1326 , Dnd_VciFF75 ] Variables DND Dnd_EcoB7A Dnd_Sli1326 Dnd_VciFF75 Classes Dnd class Dnd ( name , sequence , index_pos , index_neg ) Methylase enzyme class. Parameters name Name of the enzyme ( str ). sequence Sequence of extended nucleotide characters ( str ). index_pos Index of the methylated base on the positive strand ( int ). index_neg Index of the methylated base on the negative strand ( int ). View Source class Dnd ( Methylase ): pass Ancestors (in MRO) epijinn.Methyl.Methylase Class variables complement_table Static methods complement def complement ( sequence ) View Source @staticmethod def complement ( sequence ) : complement_letters = [ Methylase.complement_table[letter ] for letter in sequence ] complement = \"\" . join ( complement_letters ) return complement reverse def reverse ( sequence ) View Source @staticmethod def reverse ( sequence ) : reverse = sequence [ ::- 1 ] return reverse reverse_complement def reverse_complement ( sequence ) View Source @staticmethod def reverse_complement ( sequence ) : r = Methylase . reverse ( sequence ) rc = Methylase . complement ( r ) return rc","title":"Dnd"},{"location":"reference/epijinn/dnd/#module-epijinndnd","text":"View Source # Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh # # This file is part of EpiJinn. # # EpiJinn is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. # # EpiJinn is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. # # You should have received a copy of the GNU General Public License along with Ediacara. If not, see <https://www.gnu.org/licenses/>. from .Methyl import Methylase class Dnd ( Methylase ): pass Dnd_EcoB7A = Dnd ( \"Dnd_EcoB7A\" , \"GAAC\" , 0 , 3 ) Dnd_Sli1326 = Dnd ( \"Dnd_Sli1326\" , \"GGCC\" , 0 , 3 ) Dnd_VciFF75 = Dnd ( \"Dnd_VciFF75\" , \"CCA\" , 0 , 2 ) DND = [ Dnd_EcoB7A , Dnd_Sli1326 , Dnd_VciFF75 ]","title":"Module epijinn.dnd"},{"location":"reference/epijinn/dnd/#variables","text":"DND Dnd_EcoB7A Dnd_Sli1326 Dnd_VciFF75","title":"Variables"},{"location":"reference/epijinn/dnd/#classes","text":"","title":"Classes"},{"location":"reference/epijinn/dnd/#dnd","text":"class Dnd ( name , sequence , index_pos , index_neg ) Methylase enzyme class. Parameters name Name of the enzyme ( str ). sequence Sequence of extended nucleotide characters ( str ). index_pos Index of the methylated base on the positive strand ( int ). index_neg Index of the methylated base on the negative strand ( int ). View Source class Dnd ( Methylase ): pass","title":"Dnd"},{"location":"reference/epijinn/dnd/#ancestors-in-mro","text":"epijinn.Methyl.Methylase","title":"Ancestors (in MRO)"},{"location":"reference/epijinn/dnd/#class-variables","text":"complement_table","title":"Class variables"},{"location":"reference/epijinn/dnd/#static-methods","text":"","title":"Static methods"},{"location":"reference/epijinn/dnd/#complement","text":"def complement ( sequence ) View Source @staticmethod def complement ( sequence ) : complement_letters = [ Methylase.complement_table[letter ] for letter in sequence ] complement = \"\" . join ( complement_letters ) return complement","title":"complement"},{"location":"reference/epijinn/dnd/#reverse","text":"def reverse ( sequence ) View Source @staticmethod def reverse ( sequence ) : reverse = sequence [ ::- 1 ] return reverse","title":"reverse"},{"location":"reference/epijinn/dnd/#reverse_complement","text":"def reverse_complement ( sequence ) View Source @staticmethod def reverse_complement ( sequence ) : r = Methylase . reverse ( sequence ) rc = Methylase . complement ( r ) return rc","title":"reverse_complement"},{"location":"reference/epijinn/reports/","text":"Module epijinn.reports View Source # Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh # # This file is part of EpiJinn. # # EpiJinn is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. # # EpiJinn is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. # # You should have received a copy of the GNU General Public License along with Ediacara. If not, see <https://www.gnu.org/licenses/>. from datetime import datetime import os from pdf_reports import ( add_css_class , dataframe_to_html , pug_to_html , style_table_rows , write_report , ) import pdf_reports.tools as pdf_tools from .version import __version__ THIS_PATH = os . path . dirname ( os . path . realpath ( __file__ )) ASSETS_PATH = os . path . join ( THIS_PATH , \"report_assets\" ) BEDMETHYLITEMGROUP_REPORT_TEMPLATE = os . path . join ( ASSETS_PATH , \"report.pug\" ) STYLESHEET = os . path . join ( ASSETS_PATH , \"report_style.css\" ) def epijinn_pug_to_html ( template , ** context ): now = datetime . now () . strftime ( \"%Y-%m- %d \" ) defaults = { \"sidebar_text\" : \"Generated on %s by EpiJinn (version %s )\" % ( now , __version__ ), \"epijinn_logo_url\" : os . path . join ( ASSETS_PATH , \"imgs\" , \"epijinn.png\" ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) def tr_modifier_for_bed_table ( tr ): tds = list ( tr . find_all ( \"td\" )) if len ( tds ) == 0 : return methylated = tds [ - 1 ] # last column shows status if methylated . text == \"1\" : add_css_class ( tr , \"negative\" ) # else: # add_css_class(tr, \"positive\") def write_bedmethylitemgroup_report ( bedmethylitemgroup , pdf_file = \"report.pdf\" , html_file = None ): \"\"\"Write a methylation analysis report with a PDF summary. **Parameters** **bedmethylitemgroup** > `BedmethylItemGroup` instance. **pdf_file** > Optional PDF file name (`str`). Specify `None` to omit. **html_file** > Optional HTML file name (`str`). The PDF is created from this HTML data. \"\"\" for bedmethylitem in bedmethylitemgroup . bedmethylitems : bedmethylitem . bedmethylitem_figure_data = pdf_tools . figure_data ( bedmethylitem . fig , fmt = \"svg\" ) for bedresult in bedmethylitem . results : bedresult . bed_pdf = dataframe_to_html ( bedresult . bed , extra_classes = ( \"ui\" , \"compact\" , \"celled\" , # \"striped\", \"table\" , \"groups\" , ), use_default_classes = False , ) bedresult . bed_pdf = style_table_rows ( bedresult . bed_pdf , tr_modifier_for_bed_table ) if bedresult . img_created : bedresult . figure_data = pdf_tools . figure_data ( bedresult . plot , fmt = \"svg\" ) html = epijinn_pug_to_html ( BEDMETHYLITEMGROUP_REPORT_TEMPLATE , bedmethylitemgroup = bedmethylitemgroup ) if html_file : with open ( html_file , \"w\" ) as html_output : html_output . write ( html ) if pdf_file : write_report ( html , pdf_file , extra_stylesheets = ( STYLESHEET ,)) Variables ASSETS_PATH BEDMETHYLITEMGROUP_REPORT_TEMPLATE STYLESHEET THIS_PATH Functions epijinn_pug_to_html def epijinn_pug_to_html ( template , ** context ) View Source def epijinn_pug_to_html ( template , ** context ) : now = datetime . now (). strftime ( \"%Y-%m-%d\" ) defaults = { \"sidebar_text\" : \"Generated on %s by EpiJinn (version %s)\" % ( now , __version__ ), \"epijinn_logo_url\" : os . path . join ( ASSETS_PATH , \"imgs\" , \"epijinn.png\" ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) tr_modifier_for_bed_table def tr_modifier_for_bed_table ( tr ) View Source def tr_modifier_for_bed_table(tr): tds = list(tr.find_all(\"td\")) if len(tds) == 0: return methylated = tds[-1] # last column shows status if methylated.text == \"1\": add_css_class(tr, \"negative\") # else: # add_css_class(tr, \"positive\") write_bedmethylitemgroup_report def write_bedmethylitemgroup_report ( bedmethylitemgroup , pdf_file = 'report.pdf' , html_file = None ) Write a methylation analysis report with a PDF summary. Parameters bedmethylitemgroup BedmethylItemGroup instance. pdf_file Optional PDF file name ( str ). Specify None to omit. html_file Optional HTML file name ( str ). The PDF is created from this HTML data. View Source def write_bedmethylitemgroup_report ( bedmethylitemgroup , pdf_file = \"report.pdf\" , html_file = None ) : \" \"\" Write a methylation analysis report with a PDF summary. **Parameters** **bedmethylitemgroup** > `BedmethylItemGroup` instance. **pdf_file** > Optional PDF file name (`str`). Specify `None` to omit. **html_file** > Optional HTML file name (`str`). The PDF is created from this HTML data. \"\" \" for bedmethylitem in bedmethylitemgroup . bedmethylitems : bedmethylitem . bedmethylitem_figure_data = pdf_tools . figure_data ( bedmethylitem . fig , fmt = \"svg\" ) for bedresult in bedmethylitem . results : bedresult . bed_pdf = dataframe_to_html ( bedresult . bed , extra_classes = ( \"ui\" , \"compact\" , \"celled\" , # \"striped\", \"table\" , \"groups\" , ), use_default_classes = False , ) bedresult . bed_pdf = style_table_rows ( bedresult . bed_pdf , tr_modifier_for_bed_table ) if bedresult . img_created : bedresult . figure_data = pdf_tools . figure_data ( bedresult . plot , fmt = \"svg\" ) html = epijinn_pug_to_html ( BEDMETHYLITEMGROUP_REPORT_TEMPLATE , bedmethylitemgroup = bedmethylitemgroup ) if html_file : with open ( html_file , \"w\" ) as html_output : html_output . write ( html ) if pdf_file : write_report ( html , pdf_file , extra_stylesheets = ( STYLESHEET ,))","title":"Reports"},{"location":"reference/epijinn/reports/#module-epijinnreports","text":"View Source # Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh # # This file is part of EpiJinn. # # EpiJinn is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. # # EpiJinn is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. # # You should have received a copy of the GNU General Public License along with Ediacara. If not, see <https://www.gnu.org/licenses/>. from datetime import datetime import os from pdf_reports import ( add_css_class , dataframe_to_html , pug_to_html , style_table_rows , write_report , ) import pdf_reports.tools as pdf_tools from .version import __version__ THIS_PATH = os . path . dirname ( os . path . realpath ( __file__ )) ASSETS_PATH = os . path . join ( THIS_PATH , \"report_assets\" ) BEDMETHYLITEMGROUP_REPORT_TEMPLATE = os . path . join ( ASSETS_PATH , \"report.pug\" ) STYLESHEET = os . path . join ( ASSETS_PATH , \"report_style.css\" ) def epijinn_pug_to_html ( template , ** context ): now = datetime . now () . strftime ( \"%Y-%m- %d \" ) defaults = { \"sidebar_text\" : \"Generated on %s by EpiJinn (version %s )\" % ( now , __version__ ), \"epijinn_logo_url\" : os . path . join ( ASSETS_PATH , \"imgs\" , \"epijinn.png\" ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) def tr_modifier_for_bed_table ( tr ): tds = list ( tr . find_all ( \"td\" )) if len ( tds ) == 0 : return methylated = tds [ - 1 ] # last column shows status if methylated . text == \"1\" : add_css_class ( tr , \"negative\" ) # else: # add_css_class(tr, \"positive\") def write_bedmethylitemgroup_report ( bedmethylitemgroup , pdf_file = \"report.pdf\" , html_file = None ): \"\"\"Write a methylation analysis report with a PDF summary. **Parameters** **bedmethylitemgroup** > `BedmethylItemGroup` instance. **pdf_file** > Optional PDF file name (`str`). Specify `None` to omit. **html_file** > Optional HTML file name (`str`). The PDF is created from this HTML data. \"\"\" for bedmethylitem in bedmethylitemgroup . bedmethylitems : bedmethylitem . bedmethylitem_figure_data = pdf_tools . figure_data ( bedmethylitem . fig , fmt = \"svg\" ) for bedresult in bedmethylitem . results : bedresult . bed_pdf = dataframe_to_html ( bedresult . bed , extra_classes = ( \"ui\" , \"compact\" , \"celled\" , # \"striped\", \"table\" , \"groups\" , ), use_default_classes = False , ) bedresult . bed_pdf = style_table_rows ( bedresult . bed_pdf , tr_modifier_for_bed_table ) if bedresult . img_created : bedresult . figure_data = pdf_tools . figure_data ( bedresult . plot , fmt = \"svg\" ) html = epijinn_pug_to_html ( BEDMETHYLITEMGROUP_REPORT_TEMPLATE , bedmethylitemgroup = bedmethylitemgroup ) if html_file : with open ( html_file , \"w\" ) as html_output : html_output . write ( html ) if pdf_file : write_report ( html , pdf_file , extra_stylesheets = ( STYLESHEET ,))","title":"Module epijinn.reports"},{"location":"reference/epijinn/reports/#variables","text":"ASSETS_PATH BEDMETHYLITEMGROUP_REPORT_TEMPLATE STYLESHEET THIS_PATH","title":"Variables"},{"location":"reference/epijinn/reports/#functions","text":"","title":"Functions"},{"location":"reference/epijinn/reports/#epijinn_pug_to_html","text":"def epijinn_pug_to_html ( template , ** context ) View Source def epijinn_pug_to_html ( template , ** context ) : now = datetime . now (). strftime ( \"%Y-%m-%d\" ) defaults = { \"sidebar_text\" : \"Generated on %s by EpiJinn (version %s)\" % ( now , __version__ ), \"epijinn_logo_url\" : os . path . join ( ASSETS_PATH , \"imgs\" , \"epijinn.png\" ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context )","title":"epijinn_pug_to_html"},{"location":"reference/epijinn/reports/#tr_modifier_for_bed_table","text":"def tr_modifier_for_bed_table ( tr ) View Source def tr_modifier_for_bed_table(tr): tds = list(tr.find_all(\"td\")) if len(tds) == 0: return methylated = tds[-1] # last column shows status if methylated.text == \"1\": add_css_class(tr, \"negative\") # else: # add_css_class(tr, \"positive\")","title":"tr_modifier_for_bed_table"},{"location":"reference/epijinn/reports/#write_bedmethylitemgroup_report","text":"def write_bedmethylitemgroup_report ( bedmethylitemgroup , pdf_file = 'report.pdf' , html_file = None ) Write a methylation analysis report with a PDF summary. Parameters bedmethylitemgroup BedmethylItemGroup instance. pdf_file Optional PDF file name ( str ). Specify None to omit. html_file Optional HTML file name ( str ). The PDF is created from this HTML data. View Source def write_bedmethylitemgroup_report ( bedmethylitemgroup , pdf_file = \"report.pdf\" , html_file = None ) : \" \"\" Write a methylation analysis report with a PDF summary. **Parameters** **bedmethylitemgroup** > `BedmethylItemGroup` instance. **pdf_file** > Optional PDF file name (`str`). Specify `None` to omit. **html_file** > Optional HTML file name (`str`). The PDF is created from this HTML data. \"\" \" for bedmethylitem in bedmethylitemgroup . bedmethylitems : bedmethylitem . bedmethylitem_figure_data = pdf_tools . figure_data ( bedmethylitem . fig , fmt = \"svg\" ) for bedresult in bedmethylitem . results : bedresult . bed_pdf = dataframe_to_html ( bedresult . bed , extra_classes = ( \"ui\" , \"compact\" , \"celled\" , # \"striped\", \"table\" , \"groups\" , ), use_default_classes = False , ) bedresult . bed_pdf = style_table_rows ( bedresult . bed_pdf , tr_modifier_for_bed_table ) if bedresult . img_created : bedresult . figure_data = pdf_tools . figure_data ( bedresult . plot , fmt = \"svg\" ) html = epijinn_pug_to_html ( BEDMETHYLITEMGROUP_REPORT_TEMPLATE , bedmethylitemgroup = bedmethylitemgroup ) if html_file : with open ( html_file , \"w\" ) as html_output : html_output . write ( html ) if pdf_file : write_report ( html , pdf_file , extra_stylesheets = ( STYLESHEET ,))","title":"write_bedmethylitemgroup_report"},{"location":"reference/epijinn/version/","text":"Module epijinn.version View Source __version__ = \"0.1.1\"","title":"Version"},{"location":"reference/epijinn/version/#module-epijinnversion","text":"View Source __version__ = \"0.1.1\"","title":"Module epijinn.version"}]}